<?php

/** update base_url to be https **/
if ( empty($GLOBALS['base_url']) && !empty($_SERVER['HTTP_HOST']) )
{
    $GLOBALS['base_url'] = ( (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS']=='on') ? 'https://' : 'http://' ) . $_SERVER['HTTP_HOST'];
} else {
    //header('XXX: BASE_URL ALREADY SET');
}
/*
if ( !empty(getenv('CMP_AWS_S3_BUCKET')) )
{
    if ( empty(variable_get('s3fs_bucket')) )
    {
        variable_set( 's3fs_bucket',     getenv('CMP_AWS_S3_BUCKET') );
        variable_set( 'amazons3_bucket', getenv('CMP_AWS_S3_BUCKET') );
        if ( isset($GLOBALS['conf']) && isset($GLOBALS['conf']['s3fs_bucket']) )
        {
            $GLOBALS['conf']['s3fs_bucket'] = getenv('CMP_AWS_S3_BUCKET');
        }
    }

    if ( isset($_POST['s3fs_bucket']) && empty($_POST['s3fs_bucket']) )
    {
        $_POST['s3fs_bucket']    = getenv('CMP_AWS_S3_BUCKET');
        $_REQUEST['s3fs_bucket'] = getenv('CMP_AWS_S3_BUCKET');
    }
}*/


function cmp_misc_init()
{
    drupal_add_js(drupal_get_path('module', 'cmp_misc') .'/js/global.js');
    drupal_add_css(drupal_get_path('module', 'cmp_misc') .'/global_fix.css');

    // redirect users on '/search-content-items' page to '/search-content-items?items_per_page=20'
    $currentURL = request_uri();
    if($currentURL == '/search-content-items'){
        $options = array('query' => array('items_per_page' => '20'));
        drupal_goto('/search-content-items', $options);
    }

    // Add Anti-Clickjacking security
    header('X-Frame-Options: SAMEORIGIN');

}

function cmp_misc_menu() {
    $items = array();
    return $items;
}

function _get_region_node_count_by_tid($tids) {
    /*
    | field_data_field_asset_order_bottom             |
    | field_data_field_asset_order_carousel           |
    | field_data_field_asset_order_content            |
    | field_data_field_asset_order_menu               |
    | field_data_field_asset_order_sidebar            |
     * */

    /*$sql_b = 'SELECT COUNT(*) FROM node n
        INNER JOIN field_data_field_asset_order_bottom t ON n.nid = t.field_asset_order_bottom_target_id
        WHERE t.entity_id IN (' . implode(',', $tids) . ') AND n.status = 1';
    $res_b = db_query($sql_b)->fetchField();

    $sql_car = 'SELECT COUNT(*) FROM node n
        INNER JOIN field_data_field_asset_order_carousel t ON n.nid = t.field_asset_order_carousel_target_id
        WHERE t.entity_id IN (' . implode(',', $tids) . ') AND n.status = 1';
    $res_car = db_query($sql_car)->fetchField();

    $sql_con = 'SELECT COUNT(*) FROM node n
        INNER JOIN field_data_field_asset_order_content t ON n.nid = t.field_asset_order_content_target_id
        WHERE t.entity_id IN (' . implode(',', $tids) . ') AND n.status = 1';
    $res_con = db_query($sql_con)->fetchField();

    $sql_m = 'SELECT COUNT(*) FROM node n
        INNER JOIN field_data_field_asset_order_menu t ON n.nid = t.field_asset_order_menu_target_id
        WHERE t.entity_id IN (' . implode(',', $tids) . ') AND n.status = 1';
    $res_m = db_query($sql_m)->fetchField();
*/
    if ( empty($tids) ) { return 0; }
    $tid_list = implode(',',$tids);
    if ( empty($tid_list) ) { return 0; }

    $sql_s = "SELECT field_asset_topic_taxonomy_tid FROM field_data_field_asset_topic_taxonomy t
        WHERE t.entity_id IN ( $tid_list )";
    $res_s = db_query($sql_s)->fetchField();
    // if (!empty($res_s_))
    //return _get_node_count_by_tid(array($res_s));
    return $res_s;
}

function _get_node_count_by_tid($tids, $not_include_nids = null)
{
    if ( empty($tids) ) { return 0; }
    $tid_list = implode(',',$tids);
    if ( empty($tid_list) ) { return 0; }

    $nid_list = '';
    if ( is_array($not_include_nids) && !empty($not_include_nids) )
    {
        $nids = implode(',',$not_include_nids);
        if ( !empty($nids) )
        {
            $nid_list = " AND n.nid NOT IN ( $nid_list )";
        }
    }
    $sql = "
        SELECT COUNT(*)
        FROM node n
            INNER JOIN taxonomy_index t ON n.nid = t.nid
        WHERE t.tid IN ( $tid_list )
              AND n.status = 1 $nid_list";

    $res = db_query($sql)->fetchField();

    return $res;
}

function _get_child_terms_count_by_tid($tid){

    $sql = 'SELECT COUNT(*) FROM taxonomy_term_hierarchy t  WHERE t.parent = ' . $tid;

    $res = db_query($sql)->fetchField();

    return $res;
}


function cmp_misc_views_api() {
    return array(
        'api' => 3,
        'path' => drupal_get_path('module', 'cmp_misc'),
        'template path' => drupal_get_path('module', 'cmp_misc') . '/templates',
    );
}


function cmp_misc_views_pre_render(&$view) {
    $i = 0;

    if ($view->name == "sites_taxonomy_report" && $view->current_display == "summarized_report_page") {
        foreach($view->result as $row){
            $nav_count = 0;
            $asset_count = 0;
            $asset_page_count = 0;
            $term = taxonomy_term_load($row->tid);

            // nav pages
            if (isset($term->field_also_include_on_nav_page['und']) && is_array($term->field_also_include_on_nav_page['und'])) {
                $nav_count = count($term->field_also_include_on_nav_page['und']);
            }

            // asset topics
            $asset_tids  = array();
            $topic_count = 0;
            if (isset($term->field_asset_topic_taxonomy['und']) && is_array($term->field_asset_topic_taxonomy['und'])) {
                $topic_count = count($term->field_asset_topic_taxonomy['und']);
                foreach(array_values($term->field_asset_topic_taxonomy['und']) as $tid) {
                    $asset_tids[] = $tid['tid'];
                }
                $asset_count = _get_node_count_by_tid($asset_tids);
            }

            // term_child page count
            $child_term_count =_get_child_terms_count_by_tid($row->tid);
            //$term_page_count = _get_node_count_by_tid(array($row->tid));
            //$page_count= $asset_count+$term_page_count;

            $new_title = $view->result[$i]->taxonomy_term_data_name . ' ( '
                . $child_term_count . ' Child Page' . (($child_term_count!=0)?'s':'') . ', '
                . $nav_count . ' Supplemental Nav Link'. (($nav_count!=0)?'s':'') . ', '
                . $asset_count . ' Asset' . (($asset_count!=0)?'s':'') . ', '
                . $topic_count . ' Asset Node' . (($topic_count!=0)?'s':'') . ' )';

            $view->result[$i]->taxonomy_term_data_name = $new_title;
            $i++;
        }
    }
    elseif( $view->name == "content_taxonomy_report" && $view->current_display == "content_tag_report") {
        $is_asset_topic = (isset($view->exposed_data)
            && is_array($view->exposed_data)
            && $view->exposed_data['machine_name'] == 'asset_topic_taxonomy')? TRUE : FALSE;

        $is_site_structure = (isset($view->exposed_data)
            && is_array($view->exposed_data)
            && $view->exposed_data['machine_name'] == 'site_strucutre_taxonomy')? TRUE : FALSE;


        $i=0;
        foreach($view->result as $row){

            $array_tids[]=$row->tid;
            $asset_count = _get_node_count_by_tid(array($row->tid));

            $child_topics = ($is_asset_topic || $is_site_structure) ? _get_child_terms_count_by_tid($row->tid) : 0;

            if ($is_site_structure) {
                // node should be counted differently it will look for regions
                // find asset topic which is assigned to field_data_field_asset_topic_taxonomy
                $asset_tid = _get_region_node_count_by_tid(array($row->tid));
                if (is_numeric($asset_tid)) {
                    $asset_count = _get_node_count_by_tid(array($asset_tid));
                }
                $owner = _get_asset_owner_by_tid($row->tid);
            }


            $owner_txt = strlen($owner) > 0? ' is owned by ' . $owner : '' ;

            $new_title = $view->result[$i]->taxonomy_term_data_name . $owner_txt . ' ( '
                . $asset_count . ' Asset' . (($asset_count!=0)?'s':'')
                . ($is_asset_topic || $is_site_structure? (', ' . ($child_topics . ' Asset Node' . (($child_topics!=0)?'s':''))) : '')
                . ' )';

            $view->result[$i]->taxonomy_term_data_name = $new_title;
            $i++;
        }

    }
    elseif($view->name == 'overriden_content_report' && $view->current_display == 'overriden_content_report_page') {

        $new_result = array();
        foreach($view->result as $row) {
            if ($row->users_node_uid != $row->users_node_revision_uid
                && $row->users_node_revision_uid != 0
                && $row->users_node_uid != 0) {
                $new_result[] = $row;
            }

        }
        $view->result = $new_result;
    }
}

function _get_asset_owner_by_tid($tid) {
    $sql_s = "SELECT u.name FROM {field_data_field_term_owner} t
        INNER JOIN {users} u
        WHERE t.field_term_owner_target_id = u.uid AND t.entity_id IN ( $tid )";
    $user = db_query($sql_s)->fetchField();
    return $user;
}

function cmp_misc_form_views_exposed_form_alter(&$form, $form_state) {

    /*if ($form['#id'] == 'views-exposed-form-overriden-content-report-overriden-content-report-page') {
        $form['stamp']['min']['#date_format'] = 'm/d/Y';
        $form['stamp']['max']['#date_format'] = 'm/d/Y';
        dpm($form);
    }*/

}


/**
 * Has this node ever been published
 *
 * @param $node
 *   The node being queried.
 *
 * @return
 *   Boolean, True if any revision of this node had ever been published.
 */
/**/
function cmp_misc_node_ever_published($node) {
    global $user;

    if (isset($node->workbench_moderation) && !empty($node->workbench_moderation['published'])) {
        return true;
    }

    // Get the moderation history of this node.
    $query = db_select('workbench_moderation_node_history', 'm');
    $query->condition('m.nid', $node->nid)
        ->condition('m.state', 'published')
        ->fields('m',array('stamp'));

    $moderations = $query->execute()->rowCount();

    // Make sure it's an array.
    return !empty($moderations);
}
/**/


function cmp_misc_form_alter(&$form, &$form_state, $form_id)
{
    /// check to see if this is a new piece of content
    if ( (  empty($form_state['node'])
        || !isset($form_state['node']->nid)
        ||  isset($form_state['node']->is_new) )
        && in_array($form_id,array(
                'text_content_type_node_form',  'state_details_node_form',
                'state_details_node_form',      'html_content_type_node_form',
                'file_content_type_node_form',  'directory_record_content_type_node_form',
                'multimedia_content_type_node_form' ))
        &&  empty($form['field_owner']['und'][0]['target_id']['#default_value'])
        && strlen($form['field_owner']['und'][0]['target_id']['#default_value']) == 0 )
    {
        global $user;
        $currentUserStr = $user->name . " (" . $user->uid . ") ";
        $form['field_owner']['und'][0]['target_id']['#default_value'] = $currentUserStr;
    }

    // repeating the logic above for the owner fields, except for terms instead of nodes
    if ( !isset($form_state['term']->tid)
        && $form_id == 'taxonomy_form_term'
        &&  empty($form['field_term_owner']['und'][0]['target_id']['#default_value'])
        && strlen($form['field_term_owner']['und'][0]['target_id']['#default_value']) == 0 )
    {
        global $user;
        $currentUserStr = $user->name . " (" . $user->uid . ") ";
        $form['field_term_owner']['und'][0]['target_id']['#default_value'] = $currentUserStr;
    }

    // If this is the edit form for any node under the 'Text Asset' content-type
    //if ( $form_id === 'text_content_type_node_form' ) {
/*
    if ( !empty($form['#node']->workbench_moderation) ) {

        global $user;
        $isAdmin = in_array('administrator', $user->roles);

        $workflowState = $form['#node']->workbench_moderation['current']->state;
        $canApproveDelete = user_access('moderate content from awaiting_deletion to deleted',$user);
        $everPublished = cmp_misc_node_ever_published($form['#node']);

        /// if isAdmin : delete button + perm option
        if ( $isAdmin ) { return; } /// admin can always see delete
        /// if !ever_published : delete button
        if ( !$everPublished ) { return; } /// anyone can see delete
        /// if  ever_published &&  awaiting_deletion && !(state:awaiting->deleted) : disabled delete button + message
        if ( $workflowState=='awaiting_deletion' && !$canApproveDelete && !empty($form['actions']['delete']) )
        { // awaiting deletion approval
            $form['actions']['delete']['#value'] = 'Awaiting Deletion';
            $form['actions']['delete']['#type'] = 'button';
            unset($form['actions']['delete']['#submit']);
            $form['actions']['delete']['#attributes'] = array(
                'style' => 'background-color: lightgray; color: gray; outline: 1px dashed gray;',
                "onclick" => "return (false);"
            );
            return;
        }
        /// if  ever_published &&  awaiting_deletion &&  (state:awaiting->deleted) : approve soft delete button
        if ( $workflowState=='awaiting_deletion' &&  $canApproveDelete && !empty($form['actions']['delete']) )
        { // approve deletion
            $form['actions']['delete']['#value'] = 'Approve Deletion';
            return;
        }
        /// if  ever_published &&  deleted : show state
        if ( $workflowState=='deleted' && !empty($form['actions']['delete']) )
        {
            $form['actions']['delete']['#value'] = 'Already Deleted';
            $form['actions']['delete']['#type'] = 'button';
            unset($form['actions']['delete']['#submit']);
            $form['actions']['delete']['#attributes'] = array(
                'style' => 'background-color: lightgray; color: gray; outline: 1px dashed gray;',
                "onclick" => "return (false);"
            );
            return;
        }
        */
        /*
        $disableDelBtn = false;
         If this user isn't allowed to hard-delete, disabel the delete button if the node is in the soft-delete process
        if ( !$isAdmin && ( $workflowState == 'deleted' || $workflowState == 'awaiting_deletion' ) ) {
            $disableDelBtn = true;
        }

        if ( $disableDelBtn ) {
            $form['actions']['delete']['#value'] = 'Already ' . str_replace('_', ' ', $workflowState);
            $form['actions']['delete']['#type'] = 'button';
            unset($form['actions']['delete']['#submit']);
            $form['actions']['delete']['#attributes'] = array(
                'style' => 'background-color: lightgray; color: gray; outline: 1px dashed gray;',
                "onclick" => "return (false);"
            );
        }
        */
    //}
    //}
}


/**
 * Implements hook_mail_alter
 */
function cmp_misc_mail_alter(&$message) {
    //Sanitize and decode HTML entities in email subject
    $message['headers']['Content-Type'] = "html/text; charset=UTF-8; format=flowed; delsp=yes";

    // Telling email recipient which environment the email is coming from if not from Prod
    if(!empty(getenv('CMP_DRUPAL_ENVIRONMENT_NAME')) && getenv('CMP_DRUPAL_ENVIRONMENT_NAME') != 'Prod'){
        $message['subject'] = '[FROM:' . getenv('CMP_DRUPAL_ENVIRONMENT_NAME') . '] ' . $message['subject'];
    }


}

/*
 * Implements HOOK_node_presave
 */
function cmp_misc_node_presave($node) {

    // Strip trailing empty <p> tags from text-asset body fields
    if ( $node->type == 'text_content_type' && !empty($node->body['und'][0]['value']) ) {
        while ( substr($node->body['und'][0]['value'], -13) === '<p>&nbsp;</p>' ) {
            $strLen = strlen($node->body['und'][0]['value']);
            $bodyVal = $node->body['und'][0]['value'];
            $node->body['und'][0]['value'] = substr($bodyVal, 0, $strLen - 13);
        }
    }

}

/*
 * Implements HOOK_node_insert
 *
 * Pre-save node operations...
 */
function cmp_misc_node_insert($node) {

    // Strip trailing empty <p> tags from text-asset body fields
    if ( $node->type == 'text_content_type' && !empty($node->body['und'][0]['value']) ) {
        while ( substr($node->body['und'][0]['value'], -13) === '<p>&nbsp;</p>' ) {
            $strLen = strlen($node->body['und'][0]['value']);
            $bodyVal = $node->body['und'][0]['value'];
            $node->body['und'][0]['value'] = substr($bodyVal, 0, $strLen - 13);
        }
    }

    // Ensure the "Workflow State (for search indexing)" text-field is initialized
    if ( $node->type === 'text_content_type') {
        $node->field_workflow_state_search = array(
            'und' => array(
                0 => array(
                    'value' => 'draft'
                )
            )
        );
    }

}

function cmp_misc_entity_load($entities, $type)
{
    if ( $type === 'file' )
    {
        foreach ( $entities as $theEntity )
        {
            if ( !isset($theEntity->type) && isset($theEntity->uri) && strpos($theEntity->uri, 's3://') === 0 )
            {
                $theEntity->type = 'image';
            }
        }
    }
    if ( $type === 'node' )
    {
        foreach ( $entities as $theEntity )
        {
            if ( $row = db_query("select deleted, deletion_uid, deletion_timestamp, uuid from {node} where {node}.nid = {$theEntity->nid}")->fetchAssoc() )
            {
                $theEntity->deleted            = empty($row['deleted']) ? 0 : 1;
                $theEntity->deletion_uid       = $row['deletion_uid'];
                $theEntity->deletion_timestamp = $row['deletion_timestamp'];
                $theEntity->uuid               = $row['uuid'];
            }
        }
    }
}

/*
 * Implementation of hook_cronapi
 */
function cmp_misc_cronapi($op, $job = NULL) {

    $items['cmp_misc_daily_content_scan_cron'] = array(
        'description' => 'Send email to owner about stale/old content',
        'rule' => '0 3 * * *', // Every day at 3am
        'callback' => '_cmp_misc_send_report',
    );

    $items['cmp_misc_publish_and_archival_cron'] = array(
        'description' => 'Auto Publishing/Archiving Content',
        'rule' => '*/5 * * * *', // Every 5 minutes to give us time to hit 15min target
        'callback' => '_cmp_misc_check_content_freshness',
    );
    return $items;
}

function _cmp_misc_check_content_freshness()
{
    $pub = _cmp_misc_auto_publish_content();
    $arv = _cmp_misc_auto_archive_content();
    watchdog( 'cron', "FreshCheck: Auto-Publish($pub) Auto-Archive($arv)");
}

function _cmp_misc_auto_publish_content()
{
    /// trigger a workflow state transition to published, this will aoutomatically trigger a legit publish as well
    $records = db_query(
        'SELECT
                n.nid, n.vid as pub_rev, c.vid as curr_rev,
                r.status as curr_rev_status,
                d.deletion_timestamp,
                a.field_archive_date_value,
                p.field_schedule_publish_value,
                w.state
              FROM
                {node} n
                LEFT JOIN ( # use current revision
                    select nid, max(vid) as vid
                    from   {node_revision}
                    group by nid
                )                                                 c on ( c.nid = n.nid )
                LEFT JOIN {node_revision}                         r on ( r.nid = c.nid       AND r.vid = c.vid )
                LEFT JOIN {node_deleted}                          d on ( n.nid = d.nid )
                LEFT JOIN {field_revision_field_archive_date}     a on ( n.nid = a.entity_id AND c.vid = a.revision_id )
                LEFT JOIN {field_revision_field_schedule_publish} p on ( n.nid = p.entity_id AND c.vid = p.revision_id )
                LEFT JOIN {workbench_moderation_node_history}     w on ( n.nid = w.nid       AND c.vid = w.vid AND w.is_current = 1 )
              WHERE
                # node is not deleted
                ( d.deletion_state IS NULL OR d.deletion_state != :soft )
                # current revision is not already published
                AND r.status != 1
                # is not archived
                AND (
                    # no archive date set
                    a.field_archive_date_value IS NULL
                    OR (
                        # has archive date set
                        a.field_archive_date_value IS NOT NULL
                        AND # archive date is in the future
                        UNIX_TIMESTAMP(a.field_archive_date_value) > :now
                    )
                )
                # is publishable
                AND (
                    # has no publish date set
                    p.field_schedule_publish_value IS NULL
                    OR (
                        # has publish date set
                        p.field_schedule_publish_value IS NOT NULL
                        AND # publish date is in the past
                        UNIX_TIMESTAMP(p.field_schedule_publish_value) <= :now
                    )
                )
                AND w.state = :scheduled_for_publication
            ',array( ":now" => REQUEST_TIME, ":soft" => "soft", ":scheduled_for_publication" => "scheduled_for_publication"  )
    )->fetchAll();

    foreach  ( $records as $record )
    {
        $node = node_load($record->nid,$record->curr_rev);
        workbench_moderation_moderate($node,workbench_moderation_state_published());
    }
    return count($records);
}

function _cmp_misc_auto_archive_content()
{
    /// Just unplublish any nodes with a previous archive date. archive date trumps publication date
    $records = db_query(
        'SELECT
                n.nid, n.vid as curr_rev,
                n.status,
                d.deletion_state,
                a.field_archive_date_value
              FROM
                {node} n
                LEFT JOIN {node_deleted}                          d on ( n.nid = d.nid )
                LEFT JOIN {field_revision_field_archive_date}     a on ( n.nid = a.entity_id AND n.vid = a.revision_id )
              WHERE
                # node is not deleted
                ( d.deletion_state IS NULL OR d.deletion_state != :soft )
                # any revision of the node is currently published
                AND n.status = 1
                # is archivable
                AND (
                    # archive date set
                    a.field_archive_date_value IS NOT NULL
                    AND # archive date is in the past
                    UNIX_TIMESTAMP(a.field_archive_date_value) < :now
                )
            ',array( ":now" => REQUEST_TIME, ":soft" => "soft" )
    )->fetchAll();

    foreach  ( $records as $record )
    {
        $node = node_load($record->nid,$record->curr_rev);
        $node->status = 0;
        node_save($node);
    }
    return count($records);
}

function _cmp_misc_node_past_publication_date($node)
{
    /// Not deleted, not already published, not archived, has past publish date
    return db_query(
        'SELECT
                n.nid, n.vid as pub_rev, c.vid as curr_rev,
                r.status as curr_rev_status,
                d.deletion_state,
                a.field_archive_date_value,
                p.field_schedule_publish_value
              FROM
                {node} n
                LEFT JOIN ( # use current revision
                    SELECT nid, max(vid) as vid
                    FROM   {node_revision}
                    WHERE nid = :nid
                    GROUP BY nid
                )                                                 c on ( n.nid = c.nid )
                LEFT JOIN {node_revision}                         r on ( r.nid = c.nid       AND r.vid = c.vid )
                LEFT JOIN {node_deleted}                          d on ( n.nid = d.nid )
                LEFT JOIN {field_revision_field_archive_date}     a on ( n.nid = a.entity_id AND c.vid = a.revision_id )
                LEFT JOIN {field_revision_field_schedule_publish} p on ( n.nid = p.entity_id AND c.vid = p.revision_id )
                LEFT JOIN {workbench_moderation_node_history}     w on ( n.nid = w.nid       AND c.vid = w.vid AND w.is_current = 1 )
              WHERE
                # node is our node
                n.nid = :nid
                # node is not deleted
                AND ( d.deletion_state IS NULL OR d.deletion_state != :soft )
                # current revision is not already published
                AND r.status != 1
                # is not archived
                AND (
                    # no archive date set
                    a.field_archive_date_value IS NULL
                    OR (
                        # has archive date set
                        a.field_archive_date_value IS NOT NULL
                        AND # archive date is in the future
                        UNIX_TIMESTAMP(a.field_archive_date_value) > :now
                    )
                )
                # is publishable
                AND (
                    # has no publish date set
                    p.field_schedule_publish_value IS NULL
                    OR (
                        # has publish date set
                        p.field_schedule_publish_value IS NOT NULL
                        AND # publish date is in the past
                        UNIX_TIMESTAMP(p.field_schedule_publish_value) <= :now
                    )
                )
            ',array( ":nid" => $node->nid, ":now" => REQUEST_TIME, ":soft" => "soft"  )
    )->rowCount();
}

function _cmp_misc_node_future_publication_date($node)
{
    /// Not deleted, not already published, not archived, has future publish date
    return db_query(
        'SELECT
                n.nid, n.vid as pub_rev, c.vid as curr_rev,
                r.status as curr_rev_status,
                d.deletion_state,
                a.field_archive_date_value,
                p.field_schedule_publish_value
              FROM
                {node} n
                LEFT JOIN ( # use current revision
                    SELECT nid, max(vid) as vid
                    FROM   {node_revision}
                    WHERE nid = :nid
                    GROUP BY nid
                )                                                 c on ( n.nid = c.nid )
                LEFT JOIN {node_revision}                         r on ( r.nid = c.nid       AND r.vid = c.vid )
                LEFT JOIN {node_deleted}                          d on ( n.nid = d.nid )
                LEFT JOIN {field_revision_field_archive_date}     a on ( n.nid = a.entity_id AND c.vid = a.revision_id )
                LEFT JOIN {field_revision_field_schedule_publish} p on ( n.nid = p.entity_id AND c.vid = p.revision_id )
                LEFT JOIN {workbench_moderation_node_history}     w on ( n.nid = w.nid       AND c.vid = w.vid AND w.is_current = 1 )
              WHERE
                # node is our node
                n.nid = :nid
                # node is not deleted
                AND ( d.deletion_state IS NULL OR d.deletion_state != :soft )
                # current revision is not already published
                AND r.status != 1
                # is not archived
                AND (
                    # no archive date set
                    a.field_archive_date_value IS NULL
                    OR (
                        # has archive date set
                        a.field_archive_date_value IS NOT NULL
                        AND # archive date is in the future
                        UNIX_TIMESTAMP(a.field_archive_date_value) > :now
                    )
                )
                # is future-publishable
                AND (
                    # has publish date set
                    p.field_schedule_publish_value IS NOT NULL
                    AND # publish date is in the past
                    UNIX_TIMESTAMP(p.field_schedule_publish_value) > :now
                )
            ',array( ":nid" => $node->nid, ":now" => REQUEST_TIME, ":soft" => "soft"  )
    )->rowCount();
}

// function _cmp_misc_forget_recent_publish($node)
// {
//     $hist = db_query('SELECT *
// 	          FROM   workbench_moderation_node_history h
// 	          WHERE nid = :nid
// 	          ORDER BY stamp DESC LIMIT 2',array(":nid"=>$node->nid))->fetchAll();
//     if ( count($hist) == 2 && $hist[0]->state==workbench_moderation_state_published() && $hist[1]->state=='scheduled_for_publication' )
//     {
//         db_query(
//             'update {workbench_moderation_node_history} set from_state = :from_state where hid = :hid',
//             array( ":from_state"=>$hist[0]->from_state, ":hid"=>$hist[1]->hid ));
//         db_query(
//             'delete from {workbench_moderation_node_history} where hid = :hid',
//             array( ":hid"=>$hist[0]->hid ));
//     }

//     /* Bug killer - in some specific edge case, another process (after the call to this function) may set the status
//     to 1 for this node on the node table - so we shall ensure that status is 0 by use of register_shutdown_function() */
//     drupal_register_shutdown_function("db_query", "UPDATE node SET status=0 WHERE nid={$node->nid}");
// }

function _cmp_misc_get_expiring_nodes()
{
    $expiring_date = strtotime(date('Y-m-d H:i:s') . ' -6 months');

    $sql = "SELECT n.nid, n.title FROM field_data_field_date_last_reviewed lr
        INNER JOIN node n ON n.nid = lr.entity_id
        WHERE n.status = 1 AND UNIX_TIMESTAMP(lr.field_date_last_reviewed_value) <= :start_date";
    $result = db_query($sql, array(':start_date'=>$expiring_date));
    $arr = array();
    foreach($result as $row) {
        $node = node_load($row->nid);

        if (isset($node->field_owner['und'][0]['target_id'])) {
            $user = user_load($node->field_owner['und'][0]['target_id']);
            $arr[$node->field_owner['und'][0]['target_id']]['nodes'][] = l($node->title, 'node/'. $node->nid);
            $arr[$node->field_owner['und'][0]['target_id']]['name'] = $user->name;
            $arr[$node->field_owner['und'][0]['target_id']]['mail'] = $user->mail;
        }
    }
    return $arr;

}

/**
 * Allows modules to respond to state transitions.
 *
 * @param $node
 *  The node that is being transitioned.
 *
 * @param $previous_state
 *  The state of the revision before the transition occurred.
 *
 * @param $new_state
 *  The new state of the revision.
 */
function cmp_misc_workbench_moderation_transition($node, $previous_state, $new_state)
{
    #if ( $new_state == workbench_moderation_state_published()
    /// allow a user to force a published transition for items already in 'scheduled' state
    /// so two publish attempts in a row would immediately publish the content
    # && $previous_state != 'scheduled_for_publication'
    #      && _cmp_misc_node_future_publication_date($node) )
    #{
    #    workbench_moderation_moderate( $node, 'scheduled_for_publication' );
    #    _cmp_misc_forget_recent_publish($node);
    #}

    // any state >>> scheduled_for_publication
    // throw this straight to published if we can
    if ( $new_state=='scheduled_for_publication'
        && ( _cmp_misc_node_past_publication_date($node) >= 1 ) )
    {
        workbench_moderation_moderate( $node, workbench_moderation_state_published() );
    }


    // needs approval or needs_acc_approval >>> needs discussion
    if ($previous_state == 'needs_review' && $new_state == 'needs_discussion') {
        $node_vs = node_revision_list($node);
        $node_vs_index = array_keys($node_vs);

        global $user;
        $last_edited_node = $last_edited_user = '';
        if (count($node_vs) > 2) {

            // second revision will be always last person who touched
            for($i=0; $i<count($node_vs); $i++) {
                $tmp_node = $node_vs[$node_vs_index[$i]];

                if ($user->uid != $tmp_node->uid) {
                    $last_edited_node = $node_vs[$node_vs_index[$i]];
                    $last_edited_user = user_load($last_edited_node->uid);
                    break;
                }
            }

            if ($last_edited_node != '' && $last_edited_user != '')  {
                $current_node = $node_vs[$node_vs_index[0]];
                $current_user = user_load($current_node->uid);
                _cmp_misc_send_last_edited_person($last_edited_user, $node);
            }
        }
    }
    elseif($previous_state == 'needs_acc_approval' && $new_state == 'needs_discussion') {

        // http://ctac.myjetbrains.com/youtrack/issue/usagov-100605
        $sql = "SELECT * FROM workbench_moderation_node_history WHERE nid =:node_id AND from_state='draft' AND state='needs_review' ORDER BY stamp ASC LIMIT 1;";
        $node_row = db_query($sql, array(':node_id'=>$node->nid))->fetchAssoc();

        if (isset($node_row['nid']) && isset($node_row['vid'])){
            $node_rev = node_load($node_row['nid'], $node_row['vid']);
            $user_rev = user_load($node_rev->uid);
            _cmp_misc_send_last_edited_person($user_rev, $node, "Person who initially requested node from 'Draft' to 'Needs Approval' is ");
        }
    }

    // needs approval  from different state
    if ($previous_state != 'needs_review' && $new_state == 'needs_review') {
        _cmp_misc_send_needs_approval_notice_person( $node);
    }

    /* Some node(s) have a field_workflow_state_search field, which we want to always contain the current workflow-status.
    We use this field as an easy way to obtain the workflow information with the ElasticSearch mdoule... */
    if ( isset($node->field_workflow_state_search) ) { // If this node is of a content-type that has the workflow_state_search field....

        // Write the (current) workflow-status into the workflow_state_search [text] field...

        /* I am SCHEDULING this, because I am uncertain at what point this hook is called...
        Or in other words: is this hook being triggered on pre-save? post-save? I tried altering $node
        in this function, and found it did not touch the node in the database, but I feel uncomfortable
        loading and saving the node [right here] because the node may be undergoing [an incomplete] alteration
        at this line (in this function) */
        // Schedule helper-function _cmp_misc_setWorkflowStatusSearchTextField() on PHP-thread-termination
        /* register_shutdown_function(
             '_cmp_misc_setWorkflowStatusSearchTextField',
             $node->nid,
             $node->vid,
             $new_state
         );*/

    }

}

/**
 * void _cmp_misc_setWorkflowStatusSearchTextField(int $nid, string $workFlowStatusText)
 *
 * NOTICE: THIS DOES NOT CHANGE NOR TOUCH THE ACTUAL WORKFLOW-STATE IN ANY WAY!
 * This function only writes the given text to the $node->workflow_state_search field, this is
 * a field used only by Elastic-Search.
 *
 * This is created as a helper-function for cmp_misc_workbench_moderation_transition() above.
 */
function _cmp_misc_setWorkflowStatusSearchTextField($nid, $vid, $workFlowStatusText) {

    db_query("
        UPDATE field_data_field_workflow_state_search
        SET field_workflow_state_search_value = '{$workFlowStatusText}'
        WHERE
            entity_id = {$nid}
            AND revision_id = {$vid}
    ");

    db_query("
        UPDATE field_revision_field_workflow_state_search
        SET field_workflow_state_search_value = '{$workFlowStatusText}'
        WHERE
            entity_id = {$nid}
            AND revision_id = {$vid}
    ");

    entity_get_controller('node')->resetCache(array($nid));

    // Debug - for those of us who tail the error_log
    $myFunct = __FUNCTION__;
    error_log(
        "Notice: {$myFunct}() has set the current workflow-status ({$workFlowStatusText}) "
        ."into field_workflow_state_search for node {$nid}/{$vid}"
    );
}

function _cmp_misc_send_needs_approval_notice_person( $node) {

    if (isset( $node->field_workflow_notification_emai['und'][0]['value'])) {
        $to = $node->field_workflow_notification_emai['und'][0]['value'];
        global $user;

        // Subject
        $params['subject'] = "Approval Needed: " . $node->title;

        $alias = drupal_get_path_alias('node/' . $node->nid);
        // body
        $params['body'] = '<b>Content item needs approval </b> - <a href="' . $alias . '">' . $node->title . '</a> <br/>';
        $params['body'] .= '<b>Summary</b> - ' . $node->field_description['und'][0]['value'] . ' <br/>';
        $params['body'] .= '<b>User who requested review</b> - ' . $user->name . '<br/>';
        $params['body'] .= '<b>Last updated on </b>' . date('Y-m-d - H:i') . '<br/>';
        if ( !empty($node->field_comments['und'][0]['value']) ) {
            $strComment = strip_tags($node->field_comments['und'][0]['value']);
        } else {
            $strComment = '<i>No comments supplied</i>';
        }
        $params['body'] .= '<b>Comments: </b>' . $strComment;

        $from = variable_get('site_mail', '');

        $params['from'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . $from . '>');
        $params['headers']['Reply-To'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . variable_get('site_mail', '') . '>');

        $res = drupal_mail('cmp_misc', 'scanning_content', trim($to), language_default(), $params, $params['from']);

        if ($res["send"]) {
            drupal_set_message("Approval notification email has been sent." . $to);
        }
    }
}

function _cmp_misc_send_last_edited_person($user_to_send, $node, $msg=null) {
    $to = $user_to_send->mail;
    global $user;

    // Subject
    $params['subject'] = "Discussion Needed :".$node->title;

    $alias = drupal_get_path_alias('node/'.$node->nid);
    // body
    $params['body'] = '<b>Content item needs discussion</b> - <a href="' . $alias . '">' . $node->title . '</a> <br/>';
    $params['body'] .= '<b>Summary</b> - ' . $node->field_description['und'][0]['value'] . ' <br/>';
    $params['body'] .= '<b>User who requested discussion</b> - '. $user->name . '<br/>';
    $params['body'] .= '<b>Last updated on </b>' . date('Y-m-d - H:i');

    $from = variable_get('site_mail', '');

    $params['from'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . $from . '>');
    $params['headers']['Reply-To'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . variable_get('site_mail', '') . '>');

    $res = drupal_mail('cmp_misc', 'scanning_content', trim($to), language_default(), $params, $params['from']);

    if ($res["send"]) {
        drupal_set_message((($msg == null)? "Person who last revision created is ": $msg) . $user_to_send->name . ". Notification email has been sent." . $to);
    }
}

function _cmp_misc_send_report() {

    // We check and prevent developer's locals from sending emails here
    $prodStageDomains = variable_get('udm_prod_domains', array());
    if ( !in_array($_SERVER['HTTP_HOST'], $prodStageDomains) ) {
        drupal_set_message(
            __FUNCTION__.'() blocked from execution as this appears to NOT be a Dev nor Stage environment.',
            'warning',
            false
        );
        return;
    }

    watchdog('cron',"STARTED >> DAILY SCANNING CONTENT: " . date('Y-m-d H:i:s'));

    $ret = _cmp_misc_get_expiring_nodes();
    $subject = "CMP Content Scan Result: " . date('Y-m-d H:i:s');
    $res = "";

    foreach($ret as $t =>$k) {
        $to = $k['mail'] .', ariun2006@gmail.com';
        $body="Dear " . $k['name'] . ", <br />You have the following content that has not been reviewed for more than 6 months: <br/>";
        $body .= "<ul>";

        foreach($k['nodes'] as $node_link) {
            $body .= '<li>' . $node_link . '</li>';
        }

        $body .= "</ul>";

        // Subject
        $params['subject'] = $subject;

        // body
        $params['body'] = $body;


        $from = variable_get('forward_sender_address', '');
        if (empty($from)) {
            $from = variable_get('site_mail', '');
        }

        $params['from'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . $from . '>');
        $params['headers']['Reply-To'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . variable_get('site_mail', '') . '>');

        $res = drupal_mail('cmp_misc', 'scanning_content', trim($to), language_default(), $params, $params['from']);
        if ($res["send"]) {
            watchdog("cron", "DAILY SCANNING CONTENT SENT AN EMAIL TO " . $to . date('Y-m-d H:i:s'));
        }
        else {
            watchdog("cron", "DAILY SCANNING CONTENT ERROR OCCURRED ". $res["result"]);
        }
        // Flood control
        flood_register_event('cmp_misc');
    }

    watchdog('cron',"FINISHED >> DAILY SCANNING CONTENT: ". date('Y-m-d H:i:s'));

    return $res;
}
function cmp_misc_mail($key, &$message, $params) {
    $language = $message['language'];
    if ($key == 'scanning_content') {
        $message['headers']['MIME-Version'] = '1.0';
        $message['headers']['Content-Type'] = 'text/html; charset=utf-8';
        $message['headers']['Reply-To'] = $params['headers']['Reply-To'];

        $message['subject']=t($params['subject']);
        $message['body'][]=$params['body'];
        $message['headers']['Content-Type'] = 'text/html; charset=UTF-8; format=flowed';
    }
}

class Cmp_miscMailSystem implements MailSystemInterface {
    /**
     * Concatenate and wrap the e-mail body for plain-text mails.
     *
     * @param $message
     *   A message array, as described in hook_mail_alter().
     *
     * @return
     *   The formatted $message.
     */
    public function format(array $message) {
        $message['body'] = implode("\n\n", $message['body']);
        return $message;
    }

    /**
     * Send an e-mail message, using Drupal variables and default settings.
     *
     * @see http://php.net/manual/en/function.mail.php
     * @see drupal_mail()
     *
     * @param $message
     *   A message array, as described in hook_mail_alter().
     * @return
     *   TRUE if the mail was successfully accepted, otherwise FALSE.
     */
    public function mail(array $message) {
        $mimeheaders = array();
        foreach ($message['headers'] as $name => $value) {
            $mimeheaders[] = $name . ': ' . mime_header_encode($value);
        }
        $line_endings = variable_get('mail_line_endings', MAIL_LINE_ENDINGS);
        return mail(
            $message['to'],
            mime_header_encode($message['subject']),
            // Note: e-mail uses CRLF for line-endings. PHP's API requires LF
            // on Unix and CRLF on Windows. Drupal automatically guesses the
            // line-ending format appropriate for your system. If you need to
            // override this, adjust $conf['mail_line_endings'] in settings.php.
            preg_replace('@\r?\n@', $line_endings, $message['body']),
            // For headers, PHP's API suggests that we use CRLF normally,
            // but some MTAs incorrectly replace LF with CRLF. See #234403.
            join("\n", $mimeheaders)
        );
    }
}

/**
 * Implements hook_search_api_alter_callback_info()
 */
function cmp_misc_search_api_alter_callback_info() {
    $callbacks['most_recent_revision_alter'] = array(
        'name' => t('Index Most Recent Revision'),
        'description' => t('Indexes most recent revision content information to the index.'),
        'class' => 'MostRecentRevisionStateAlterSettings',
        'weight' => 100,
    );

    return $callbacks;
}

/**
 * @file
 * Search API data alteration callback that changes data before send to elastic search
 */
class MostRecentRevisionStateAlterSettings extends SearchApiAbstractAlterCallback {

    public function alterItems(array &$items) {
        foreach ($items as $id => &$item) {

            $sql = "SELECT MAX(vid) FROM {node_revision} WHERE nid =:nid";
            $recent_vid = db_query($sql, array(':nid'=>$id))->fetchField();

            $sql = 'SELECT vid FROM {node} WHERE nid=:nid ';
            $node_vid = db_query($sql, array(':nid'=>$id))->fetchField();

            $current_node = node_load($id, $recent_vid);
            if ($recent_vid != $node_vid) {

                foreach($current_node as $key => $value) {
                    if(property_exists($item, $key)) {
                        $item->{$key} = $value ;
                    }
                }
            }
            if ( isset($current_node->workbench_moderation) ) {
                $item->field_workflow_state_search['und'][0]['value']= $current_node->workbench_moderation['current']->state;
                $item->field_workflow_state_search['und'][0]['safe_value']= $current_node->workbench_moderation['current']->state;
            }
            // node is text or directory content type, we need to add use by field
            if ($current_node->type == 'directory_record_content_type' || $current_node->type == 'text_content_type') {
                if ( isset($item->field_for_use_by_text) ) {
                    $item->field_for_use_by = $item->field_for_use_by_text;
                }
            }
            else {
                if ( isset($item->field_for_use_by) ) {
                    $item->field_for_use_by_text = $item->field_for_use_by;
                }
            }
        }
    }

}

function cmp_misc_wysiwyg_editor_settings_alter(&$settings, $context)
{
  if ( trim(strtolower($context['profile']->editor)) === 'ckeditor')
  {
    // $m = menu_get_item();
    // if ( isset($m['page_arguments']) && isset($m['page_arguments'][0]) )
    // {
    //   $l = null;
    //   if ( !empty($m['page_arguments'][0]->nid) )
    //   {
    //     $meta = entity_metadata_wrapper('node', $m['page_arguments'][0]);
    //     $fl = $meta->field_language->value();
    //     if      ( $fl == 'English' ) { $l = 'en_US'; }
    //     else if ( $fl == 'Spanish' ) { $l = 'es_ES'; }
    //   } else if ( !empty($m['page_arguments'][0]->language) ) {
    //     $l = $m['page_arguments'][0]->language;
    //     if      ( $l == 'en' ) { $l = 'en_US'; }
    //     else if ( $l == 'es' ) { $l = 'es_ES'; }
    //   }
    //   if ( !empty($l) )
    //   {
    //     $settings['scayt_sLang'] = $l;
    //   }
    // }
    $settings['scayt_autoStartup'] = TRUE;
  }
}

if ( !function_exists('_bloggov_urlFriendlyString') )
{
    function _bloggov_urlFriendlyString($string) {

        $string = _diacritichandler_remove_accents($string);

        $string = trim($string);
        $string = strtolower($string);
        $string = preg_replace('/[\x00-\x1F\x80-\xFF]/', '', $string);

        $replaceWithDashe = array('_', '/', "\\", ' ', '.', '~', '(', ')', '[', ']', ':', ';', '!', '@', '”', '"', "'", "?");

        $string = str_replace($replaceWithDashe, '-', $string);

        while ( strpos($string, '--') !== false ) {
            $string = str_replace('--', '-', $string);
        }

        // convert diacritics

        // $string = strtr($string, array(
        //     ' '=>'-', 'Š'=>'S', 'š'=>'s', 'Ð'=>'Dj', 'Ž'=>'Z', 'ž'=>'z', 'C'=>'C', 'c'=>'c', 'C'=>'C', 'c'=>'c',
        //     'À'=>'A', 'Á'=>'A', 'Â'=>'A', 'Ã'=>'A', 'Ä'=>'A', 'Å'=>'A', 'Æ'=>'A', 'Ç'=>'C', 'È'=>'E', 'É'=>'E',
        //     'Ê'=>'E', 'Ë'=>'E', 'Ì'=>'I', 'Í'=>'I', 'Î'=>'I', 'Ï'=>'I', 'Ñ'=>'N', 'Ò'=>'O', 'Ó'=>'O', 'Ô'=>'O',
        //     'Õ'=>'O', 'Ö'=>'O', 'Ø'=>'O', 'Ù'=>'U', 'Ú'=>'U', 'Û'=>'U', 'Ü'=>'U', 'Ý'=>'Y', 'Þ'=>'B', 'ß'=>'Ss',
        //     'à'=>'a', 'á'=>'a', 'â'=>'a', 'ã'=>'a', 'ä'=>'a', 'å'=>'a', 'æ'=>'a', 'ç'=>'c', 'è'=>'e', 'é'=>'e',
        //     'ê'=>'e', 'ë'=>'e', 'ì'=>'i', 'í'=>'i', 'î'=>'i', 'ï'=>'i', 'ð'=>'o', 'ñ'=>'n', 'ò'=>'o', 'ó'=>'o',
        //     'ô'=>'o', 'õ'=>'o', 'ö'=>'o', 'ø'=>'o', 'ù'=>'u', 'ú'=>'u', 'û'=>'u', 'ý'=>'y', 'ý'=>'y', 'þ'=>'b',
        //     'ÿ'=>'y', 'R'=>'R', 'r'=>'r', "'"=>'-', '"'=>'-', '?'=>''
        // ));

        $string = trim($string, '-');
        return $string;
    }
}

if ( !function_exists('_diacritichandler_remove_accents') )
{
    function _diacritichandler_remove_accents($string)
    {
         if ( !preg_match('/[\x80-\xff]/', $string) )
                 return $string;

         if (_diacritichandler_seems_utf8($string)) {
                 $chars = array(
                 // Decompositions for Latin-1 Supplement
                 chr(194).chr(170) => 'a', chr(194).chr(186) => 'o',
                 chr(195).chr(128) => 'A', chr(195).chr(129) => 'A',
                 chr(195).chr(130) => 'A', chr(195).chr(131) => 'A',
                 chr(195).chr(132) => 'A', chr(195).chr(133) => 'A',
                 chr(195).chr(134) => 'AE',chr(195).chr(135) => 'C',
                 chr(195).chr(136) => 'E', chr(195).chr(137) => 'E',
                 chr(195).chr(138) => 'E', chr(195).chr(139) => 'E',
                 chr(195).chr(140) => 'I', chr(195).chr(141) => 'I',
                 chr(195).chr(142) => 'I', chr(195).chr(143) => 'I',
                 chr(195).chr(144) => 'D', chr(195).chr(145) => 'N',
                 chr(195).chr(146) => 'O', chr(195).chr(147) => 'O',
                 chr(195).chr(148) => 'O', chr(195).chr(149) => 'O',
                 chr(195).chr(150) => 'O', chr(195).chr(153) => 'U',
                 chr(195).chr(154) => 'U', chr(195).chr(155) => 'U',
                 chr(195).chr(156) => 'U', chr(195).chr(157) => 'Y',
                 chr(195).chr(158) => 'TH',chr(195).chr(159) => 's',
                 chr(195).chr(160) => 'a', chr(195).chr(161) => 'a',
                 chr(195).chr(162) => 'a', chr(195).chr(163) => 'a',
                 chr(195).chr(164) => 'a', chr(195).chr(165) => 'a',
                 chr(195).chr(166) => 'ae',chr(195).chr(167) => 'c',
                 chr(195).chr(168) => 'e', chr(195).chr(169) => 'e',
                 chr(195).chr(170) => 'e', chr(195).chr(171) => 'e',
                 chr(195).chr(172) => 'i', chr(195).chr(173) => 'i',
                 chr(195).chr(174) => 'i', chr(195).chr(175) => 'i',
                 chr(195).chr(176) => 'd', chr(195).chr(177) => 'n',
                 chr(195).chr(178) => 'o', chr(195).chr(179) => 'o',
                 chr(195).chr(180) => 'o', chr(195).chr(181) => 'o',
                 chr(195).chr(182) => 'o', chr(195).chr(184) => 'o',
                 chr(195).chr(185) => 'u', chr(195).chr(186) => 'u',
                 chr(195).chr(187) => 'u', chr(195).chr(188) => 'u',
                 chr(195).chr(189) => 'y', chr(195).chr(190) => 'th',
                 chr(195).chr(191) => 'y', chr(195).chr(152) => 'O',
                 // Decompositions for Latin Extended-A
                 chr(196).chr(128) => 'A', chr(196).chr(129) => 'a',
                 chr(196).chr(130) => 'A', chr(196).chr(131) => 'a',
                 chr(196).chr(132) => 'A', chr(196).chr(133) => 'a',
                 chr(196).chr(134) => 'C', chr(196).chr(135) => 'c',
                 chr(196).chr(136) => 'C', chr(196).chr(137) => 'c',
                 chr(196).chr(138) => 'C', chr(196).chr(139) => 'c',
                 chr(196).chr(140) => 'C', chr(196).chr(141) => 'c',
                 chr(196).chr(142) => 'D', chr(196).chr(143) => 'd',
                 chr(196).chr(144) => 'D', chr(196).chr(145) => 'd',
                 chr(196).chr(146) => 'E', chr(196).chr(147) => 'e',
                 chr(196).chr(148) => 'E', chr(196).chr(149) => 'e',
                 chr(196).chr(150) => 'E', chr(196).chr(151) => 'e',
                 chr(196).chr(152) => 'E', chr(196).chr(153) => 'e',
                 chr(196).chr(154) => 'E', chr(196).chr(155) => 'e',
                 chr(196).chr(156) => 'G', chr(196).chr(157) => 'g',
                 chr(196).chr(158) => 'G', chr(196).chr(159) => 'g',
                 chr(196).chr(160) => 'G', chr(196).chr(161) => 'g',
                 chr(196).chr(162) => 'G', chr(196).chr(163) => 'g',
                 chr(196).chr(164) => 'H', chr(196).chr(165) => 'h',
                 chr(196).chr(166) => 'H', chr(196).chr(167) => 'h',
                 chr(196).chr(168) => 'I', chr(196).chr(169) => 'i',
                 chr(196).chr(170) => 'I', chr(196).chr(171) => 'i',
                 chr(196).chr(172) => 'I', chr(196).chr(173) => 'i',
                 chr(196).chr(174) => 'I', chr(196).chr(175) => 'i',
                 chr(196).chr(176) => 'I', chr(196).chr(177) => 'i',
                 chr(196).chr(178) => 'IJ',chr(196).chr(179) => 'ij',
                 chr(196).chr(180) => 'J', chr(196).chr(181) => 'j',
                 chr(196).chr(182) => 'K', chr(196).chr(183) => 'k',
                 chr(196).chr(184) => 'k', chr(196).chr(185) => 'L',
                 chr(196).chr(186) => 'l', chr(196).chr(187) => 'L',
                 chr(196).chr(188) => 'l', chr(196).chr(189) => 'L',
                 chr(196).chr(190) => 'l', chr(196).chr(191) => 'L',
                 chr(197).chr(128) => 'l', chr(197).chr(129) => 'L',
                 chr(197).chr(130) => 'l', chr(197).chr(131) => 'N',
                 chr(197).chr(132) => 'n', chr(197).chr(133) => 'N',
                 chr(197).chr(134) => 'n', chr(197).chr(135) => 'N',
                 chr(197).chr(136) => 'n', chr(197).chr(137) => 'N',
                 chr(197).chr(138) => 'n', chr(197).chr(139) => 'N',
                 chr(197).chr(140) => 'O', chr(197).chr(141) => 'o',
                 chr(197).chr(142) => 'O', chr(197).chr(143) => 'o',
                 chr(197).chr(144) => 'O', chr(197).chr(145) => 'o',
                 chr(197).chr(146) => 'OE',chr(197).chr(147) => 'oe',
                 chr(197).chr(148) => 'R',chr(197).chr(149) => 'r',
                 chr(197).chr(150) => 'R',chr(197).chr(151) => 'r',
                 chr(197).chr(152) => 'R',chr(197).chr(153) => 'r',
                 chr(197).chr(154) => 'S',chr(197).chr(155) => 's',
                 chr(197).chr(156) => 'S',chr(197).chr(157) => 's',
                 chr(197).chr(158) => 'S',chr(197).chr(159) => 's',
                 chr(197).chr(160) => 'S', chr(197).chr(161) => 's',
                 chr(197).chr(162) => 'T', chr(197).chr(163) => 't',
                 chr(197).chr(164) => 'T', chr(197).chr(165) => 't',
                 chr(197).chr(166) => 'T', chr(197).chr(167) => 't',
                 chr(197).chr(168) => 'U', chr(197).chr(169) => 'u',
                 chr(197).chr(170) => 'U', chr(197).chr(171) => 'u',
                 chr(197).chr(172) => 'U', chr(197).chr(173) => 'u',
                 chr(197).chr(174) => 'U', chr(197).chr(175) => 'u',
                 chr(197).chr(176) => 'U', chr(197).chr(177) => 'u',
                 chr(197).chr(178) => 'U', chr(197).chr(179) => 'u',
                 chr(197).chr(180) => 'W', chr(197).chr(181) => 'w',
                 chr(197).chr(182) => 'Y', chr(197).chr(183) => 'y',
                 chr(197).chr(184) => 'Y', chr(197).chr(185) => 'Z',
                 chr(197).chr(186) => 'z', chr(197).chr(187) => 'Z',
                 chr(197).chr(188) => 'z', chr(197).chr(189) => 'Z',
                 chr(197).chr(190) => 'z', chr(197).chr(191) => 's',
                 // Decompositions for Latin Extended-B
                 chr(200).chr(152) => 'S', chr(200).chr(153) => 's',
                 chr(200).chr(154) => 'T', chr(200).chr(155) => 't',
                 // Euro Sign
                 chr(226).chr(130).chr(172) => 'E',
                 // GBP (Pound) Sign
                 chr(194).chr(163) => '',
                 // Vowels with diacritic (Vietnamese)
                 // unmarked
                 chr(198).chr(160) => 'O', chr(198).chr(161) => 'o',
                 chr(198).chr(175) => 'U', chr(198).chr(176) => 'u',
                 // grave accent
                 chr(225).chr(186).chr(166) => 'A', chr(225).chr(186).chr(167) => 'a',
                 chr(225).chr(186).chr(176) => 'A', chr(225).chr(186).chr(177) => 'a',
                 chr(225).chr(187).chr(128) => 'E', chr(225).chr(187).chr(129) => 'e',
                 chr(225).chr(187).chr(146) => 'O', chr(225).chr(187).chr(147) => 'o',
                 chr(225).chr(187).chr(156) => 'O', chr(225).chr(187).chr(157) => 'o',
                 chr(225).chr(187).chr(170) => 'U', chr(225).chr(187).chr(171) => 'u',
                 chr(225).chr(187).chr(178) => 'Y', chr(225).chr(187).chr(179) => 'y',
                 // hook
                 chr(225).chr(186).chr(162) => 'A', chr(225).chr(186).chr(163) => 'a',
                 chr(225).chr(186).chr(168) => 'A', chr(225).chr(186).chr(169) => 'a',
                 chr(225).chr(186).chr(178) => 'A', chr(225).chr(186).chr(179) => 'a',
                 chr(225).chr(186).chr(186) => 'E', chr(225).chr(186).chr(187) => 'e',
                 chr(225).chr(187).chr(130) => 'E', chr(225).chr(187).chr(131) => 'e',
                 chr(225).chr(187).chr(136) => 'I', chr(225).chr(187).chr(137) => 'i',
                 chr(225).chr(187).chr(142) => 'O', chr(225).chr(187).chr(143) => 'o',
                 chr(225).chr(187).chr(148) => 'O', chr(225).chr(187).chr(149) => 'o',
                 chr(225).chr(187).chr(158) => 'O', chr(225).chr(187).chr(159) => 'o',
                 chr(225).chr(187).chr(166) => 'U', chr(225).chr(187).chr(167) => 'u',
                 chr(225).chr(187).chr(172) => 'U', chr(225).chr(187).chr(173) => 'u',
                 chr(225).chr(187).chr(182) => 'Y', chr(225).chr(187).chr(183) => 'y',
                 // tilde
                 chr(225).chr(186).chr(170) => 'A', chr(225).chr(186).chr(171) => 'a',
                 chr(225).chr(186).chr(180) => 'A', chr(225).chr(186).chr(181) => 'a',
                 chr(225).chr(186).chr(188) => 'E', chr(225).chr(186).chr(189) => 'e',
                 chr(225).chr(187).chr(132) => 'E', chr(225).chr(187).chr(133) => 'e',
                 chr(225).chr(187).chr(150) => 'O', chr(225).chr(187).chr(151) => 'o',
                 chr(225).chr(187).chr(160) => 'O', chr(225).chr(187).chr(161) => 'o',
                 chr(225).chr(187).chr(174) => 'U', chr(225).chr(187).chr(175) => 'u',
                 chr(225).chr(187).chr(184) => 'Y', chr(225).chr(187).chr(185) => 'y',
                 // acute accent
                 chr(225).chr(186).chr(164) => 'A', chr(225).chr(186).chr(165) => 'a',
                 chr(225).chr(186).chr(174) => 'A', chr(225).chr(186).chr(175) => 'a',
                 chr(225).chr(186).chr(190) => 'E', chr(225).chr(186).chr(191) => 'e',
                 chr(225).chr(187).chr(144) => 'O', chr(225).chr(187).chr(145) => 'o',
                 chr(225).chr(187).chr(154) => 'O', chr(225).chr(187).chr(155) => 'o',
                 chr(225).chr(187).chr(168) => 'U', chr(225).chr(187).chr(169) => 'u',
                 // dot below
                 chr(225).chr(186).chr(160) => 'A', chr(225).chr(186).chr(161) => 'a',
                 chr(225).chr(186).chr(172) => 'A', chr(225).chr(186).chr(173) => 'a',
                 chr(225).chr(186).chr(182) => 'A', chr(225).chr(186).chr(183) => 'a',
                 chr(225).chr(186).chr(184) => 'E', chr(225).chr(186).chr(185) => 'e',
                 chr(225).chr(187).chr(134) => 'E', chr(225).chr(187).chr(135) => 'e',
                 chr(225).chr(187).chr(138) => 'I', chr(225).chr(187).chr(139) => 'i',
                 chr(225).chr(187).chr(140) => 'O', chr(225).chr(187).chr(141) => 'o',
                 chr(225).chr(187).chr(152) => 'O', chr(225).chr(187).chr(153) => 'o',
                 chr(225).chr(187).chr(162) => 'O', chr(225).chr(187).chr(163) => 'o',
                 chr(225).chr(187).chr(164) => 'U', chr(225).chr(187).chr(165) => 'u',
                 chr(225).chr(187).chr(176) => 'U', chr(225).chr(187).chr(177) => 'u',
                 chr(225).chr(187).chr(180) => 'Y', chr(225).chr(187).chr(181) => 'y',
                 // Vowels with diacritic (Chinese, Hanyu Pinyin)
                 chr(201).chr(145) => 'a',
                 // macron
                 chr(199).chr(149) => 'U', chr(199).chr(150) => 'u',
                 // acute accent
                 chr(199).chr(151) => 'U', chr(199).chr(152) => 'u',
                 // caron
                 chr(199).chr(141) => 'A', chr(199).chr(142) => 'a',
                 chr(199).chr(143) => 'I', chr(199).chr(144) => 'i',
                 chr(199).chr(145) => 'O', chr(199).chr(146) => 'o',
                 chr(199).chr(147) => 'U', chr(199).chr(148) => 'u',
                 chr(199).chr(153) => 'U', chr(199).chr(154) => 'u',
                 // grave accent
                 chr(199).chr(155) => 'U', chr(199).chr(156) => 'u',
                 );

                    $string = strtr($string, $chars);
            } else {
                    // Assume ISO-8859-1 if not UTF-8
                    $chars['in'] = chr(128).chr(131).chr(138).chr(142).chr(154).chr(158)
                            .chr(159).chr(162).chr(165).chr(181).chr(192).chr(193).chr(194)
                            .chr(195).chr(196).chr(197).chr(199).chr(200).chr(201).chr(202)
                            .chr(203).chr(204).chr(205).chr(206).chr(207).chr(209).chr(210)
                            .chr(211).chr(212).chr(213).chr(214).chr(216).chr(217).chr(218)
                            .chr(219).chr(220).chr(221).chr(224).chr(225).chr(226).chr(227)
                            .chr(228).chr(229).chr(231).chr(232).chr(233).chr(234).chr(235)
                            .chr(236).chr(237).chr(238).chr(239).chr(241).chr(242).chr(243)
                            .chr(244).chr(245).chr(246).chr(248).chr(249).chr(250).chr(251)
                            .chr(252).chr(253).chr(255);

                    $chars['out'] = "EfSZszYcYuAAAAAACEEEEIIIINOOOOOOUUUUYaaaaaaceeeeiiiinoooooouuuuyy";

                    $string = strtr($string, $chars['in'], $chars['out']);
                    $double_chars['in'] = array(chr(140), chr(156), chr(198), chr(208), chr(222), chr(223), chr(230), chr(240), chr(254));
                    $double_chars['out'] = array('OE', 'oe', 'AE', 'DH', 'TH', 'ss', 'ae', 'dh', 'th');
                    $string = str_replace($double_chars['in'], $double_chars['out'], $string);
            }

            return $string;
    }
}
if ( !function_exists('_diacritichandler_seems_utf8') )
{
    function _diacritichandler_seems_utf8($str)
    {
         $length = strlen($str);
         for ($i=0; $i < $length; $i++) {
                 $c = ord($str[$i]);
                 if ($c < 0x80) $n = 0; # 0bbbbbbb
                 elseif (($c & 0xE0) == 0xC0) $n=1; # 110bbbbb
                 elseif (($c & 0xF0) == 0xE0) $n=2; # 1110bbbb
                 elseif (($c & 0xF8) == 0xF0) $n=3; # 11110bbb
                 elseif (($c & 0xFC) == 0xF8) $n=4; # 111110bb
                 elseif (($c & 0xFE) == 0xFC) $n=5; # 1111110b
                 else return false; # Does not match any model
                 for ($j=0; $j<$n; $j++) { # n bytes matching 10bbbbbb follow ?
                         if ((++$i == $length) || ((ord($str[$i]) & 0xC0) != 0x80))
                                 return false;
                 }
         }
         return true;
    }
}
