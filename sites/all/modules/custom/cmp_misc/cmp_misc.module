<?php

use Aws\Common\Aws;

/** update base_url to be https **/
if ( empty($GLOBALS['base_url']) && !empty($_SERVER['HTTP_HOST']) )
{
    $GLOBALS['base_url'] = ( (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS']=='on') ? 'https://' : 'http://' ) . $_SERVER['HTTP_HOST'];
}

// function cmp_misc_cronapi()
// {
//     $items['analytics_realtime'] = array(
//         'description' => 'Trigger realtime Analytics Reports',
//         'rule' => '*/5 * * * *',
//         'callback' => '_cmp_misc_analytics_report_trigger',
//         'arguments' => array('realtime'),
//     );
//     $items['analytics_hourly'] = array(
//         'description' => 'Trigger hourly Analytics Reports',
//         'rule' => '*/5 * * * *',
//         'callback' => '_cmp_misc_analytics_report_trigger',
//         'arguments' => array('hourly'),
//     );
//     $items['analytics_daily'] = array(
//         'description' => 'Trigger daily Analytics Reports',
//         'rule' => '*/5 * * * *',
//         'callback' => '_cmp_misc_analytics_report_trigger',
//         'arguments' => array('daily'),
//     );
//     return $items;
// }
// function _cmp_misc_analytics_report_trigger() {
//     /// how do i get the config info to instance profile
//     /// is the sdk smart enough to figure that out if I just 
//     /// don't pass access/secret?
//     // $config['awssdk2_access_key']
//     // $config['awssdk2_secret_key']
// }


function cmp_misc_audit_log(Auditlog $log) {
    $roles = user_roles(TRUE);
    foreach ( $log->role_ids as $i=>$rid  ) {
        $log->role_ids[$i] = $rid.':'.$roles[$rid];
    }
    watchdog('audit',print_r($log,1),null,WATCHDOG_WARNING);
}
function cmp_misc_user_login(&$edit, $account) {
  watchdog('audit','User login name:"%name" uid:%uid',[
        '%name' => $account->name,
        '%uid'  => $account->uid
  ],WATCHDOG_WARNING);
  // if (isset($edit['redirect']) && !empty($edit['redirect'])) {
  //   drupal_goto($edit['redirect']);
  // }
}
function cmp_misc_user_logout($account) {
  watchdog('audit','User logout name:"%name" uid:%uid',[
        '%name' => $account->name,
        '%uid'  => $account->uid
  ],WATCHDOG_WARNING);
}
function cmp_misc_user_presave(&$edit, $account, $category)
{
    global $user;
    if ($account->uid > 0 && array_key_exists('roles', $edit)) {
        $roles         = user_roles(TRUE);
        $account       = user_load($account->uid);
        $old_roles     = array_keys($account->roles);
        $new_roles     = array_keys(array_filter($edit['roles'],function($v){ return ($v!=0); }));
        $roles_added   = array_diff($new_roles, $old_roles);
        $roles_removed = array_diff($old_roles, $new_roles);
        foreach ($roles_added as $role_id) {
          watchdog('audit','Added role "%role" rid:%rid to user "%acctname" uid:%acctuid, by user "%name" uid:%uid',[
                '%role' => $roles[$role_id],
                '%rid'  => $role_id,
                '%acctname' => $account->name,
                '%acctuid'  => $account->uid,
                '%name' => $user->name,
                '%uid'  => $user->uid
            ],WATCHDOG_WARNING);
        }
        foreach ($roles_removed as $role_id) {
          watchdog('audit','Removed role "%role" rid:%rid from user "%acctname" uid:%acctuid, by user "%name" uid:%uid',[
                '%role' => $roles[$role_id],
                '%rid'  => $role_id,
                '%acctname' => $account->name,
                '%acctuid'  => $account->uid,
                '%name' => $user->name,
                '%uid'  => $user->uid
            ],WATCHDOG_WARNING);
        }
    }
}
function cmp_misc_user_insert(&$edit, $account, $category) {
    global $user;
    watchdog('audit','Added user "%acctname" uid:%acctuid, by user "%name" uid:%uid',[
        '%acctname'=>$account->name,
        '%acctuid'=>$account->uid,
        '%name'=>$user->name,
        '%uid'=>$user->uid
    ],WATCHDOG_WARNING);
}
function cmp_misc_user_delete($account) {
    global $user;
    watchdog('audit','Deleted user "%acctname" uid:%acctuid, by user "%name" uid:%uid',[
        '%acctname'=>$account->name,
        '%acctuid'=>$account->uid,
        '%name'=>$user->name,
        '%uid'=>$user->uid
    ],WATCHDOG_WARNING);
}
function cmp_misc_entity_property_info_alter(&$info) {
    $info['node']['properties']['title_string'] = array(
        'type' => 'text',
        'label' => t('Title String'),
        'sanitized' => TRUE,
        'getter callback' => 'cmp_misc_search_api_property_title_string_getter_callback',
    );
    return $info;
}
function cmp_misc_search_api_property_title_string_getter_callback($item) {
    return $item->title;
}

function cmp_misc_init()
{
    drupal_add_js(drupal_get_path('module', 'cmp_misc') .'/js/global.js');
    drupal_add_css(drupal_get_path('module', 'cmp_misc') .'/global_fix.css');

    // redirect users on '/search-content-items' page to '/search-content-items?items_per_page=20'
    $currentURL = request_uri();
    if($currentURL == '/search-content-items'){
        $options = array('query' => array('items_per_page' => '20'));
        drupal_goto('/search-content-items', $options);
    }

    // Add Anti-Clickjacking security
    header('X-Frame-Options: SAMEORIGIN');
    // do user login into splunk
 //   _cmp_misc_loginto_splunk();
}

function _cmp_misc_loginto_splunk(){
    if (db_table_exists('login_history')) {
        /*
         * db_query("ALTER TABLE login_history ADD sent_to_splunk bool;");
         * */
        $res = db_query("SELECT * FROM login_history WHERE sent_to_splunk IS NULL");
        foreach ($res as $r) {
            $user = user_load($r->uid);
            dsm($user->name . ' is logged in');
            error_log($user->name . ' is logged in. _cmp_misc_loginto_splunk');
            db_query('UPDATE login_history SET sent_to_splunk = true WHERE login_id = :login_id', array(':login_id' => $r->login_id));
        }
    }
    else {
        drupal_set_message("Please enable LOGIN HISTORY module!");
    }
}

function cmp_misc_menu() {
    $items = array();
    return $items;
}

function _get_region_node_count_by_tid($tids) {
    /*
    | field_data_field_asset_order_bottom             |
    | field_data_field_asset_order_carousel           |
    | field_data_field_asset_order_content            |
    | field_data_field_asset_order_menu               |
    | field_data_field_asset_order_sidebar            |
     * */

    /*$sql_b = 'SELECT COUNT(*) FROM node n
        INNER JOIN field_data_field_asset_order_bottom t ON n.nid = t.field_asset_order_bottom_target_id
        WHERE t.entity_id IN (' . implode(',', $tids) . ') AND n.status = 1';
    $res_b = db_query($sql_b)->fetchField();

    $sql_car = 'SELECT COUNT(*) FROM node n
        INNER JOIN field_data_field_asset_order_carousel t ON n.nid = t.field_asset_order_carousel_target_id
        WHERE t.entity_id IN (' . implode(',', $tids) . ') AND n.status = 1';
    $res_car = db_query($sql_car)->fetchField();

    $sql_con = 'SELECT COUNT(*) FROM node n
        INNER JOIN field_data_field_asset_order_content t ON n.nid = t.field_asset_order_content_target_id
        WHERE t.entity_id IN (' . implode(',', $tids) . ') AND n.status = 1';
    $res_con = db_query($sql_con)->fetchField();

    $sql_m = 'SELECT COUNT(*) FROM node n
        INNER JOIN field_data_field_asset_order_menu t ON n.nid = t.field_asset_order_menu_target_id
        WHERE t.entity_id IN (' . implode(',', $tids) . ') AND n.status = 1';
    $res_m = db_query($sql_m)->fetchField();
    */
    if ( empty($tids) ) { return 0; }
    $tid_list = implode(',',$tids);
    if ( empty($tid_list) ) { return 0; }

    $sql_s = "SELECT field_asset_topic_taxonomy_tid FROM field_data_field_asset_topic_taxonomy t
        WHERE t.entity_id IN ( $tid_list )";
    $res_s = db_query($sql_s)->fetchField();
    // if (!empty($res_s_))
    //return _get_node_count_by_tid(array($res_s));
    return $res_s;
}

function _get_node_count_by_tid($tids, $not_include_nids = null)
{
    if ( empty($tids) ) { return 0; }
    $tid_list = implode(',',$tids);
    if ( empty($tid_list) ) { return 0; }

    $nid_list = '';
    if ( is_array($not_include_nids) && !empty($not_include_nids) )
    {
        $nids = implode(',',$not_include_nids);
        if ( !empty($nids) )
        {
            $nid_list = " AND n.nid NOT IN ( $nid_list )";
        }
    }
    $sql = "
        SELECT COUNT(*)
        FROM node n
            INNER JOIN taxonomy_index t ON n.nid = t.nid
        WHERE t.tid IN ( $tid_list )
              AND n.status = 1 $nid_list";

    $res = db_query($sql)->fetchField();

    return $res;
}

function _get_child_terms_count_by_tid($tid){

    $sql = 'SELECT COUNT(*) FROM taxonomy_term_hierarchy t  WHERE t.parent = ' . $tid;

    $res = db_query($sql)->fetchField();

    return $res;
}


function cmp_misc_views_api() {
    return array(
        'api' => 3,
        'path' => drupal_get_path('module', 'cmp_misc'),
        'template path' => drupal_get_path('module', 'cmp_misc') . '/templates',
    );
}


function cmp_misc_views_pre_render(&$view) {
    $i = 0;

    if ($view->name == "sites_taxonomy_report" && $view->current_display == "summarized_report_page") {
        foreach($view->result as $row){
            $nav_count = 0;
            $asset_count = 0;
            $asset_page_count = 0;
            $term = taxonomy_term_load($row->tid);

            // nav pages
            if (isset($term->field_also_include_on_nav_page['und']) && is_array($term->field_also_include_on_nav_page['und'])) {
                $nav_count = count($term->field_also_include_on_nav_page['und']);
            }

            // asset topics
            $asset_tids  = array();
            $topic_count = 0;
            if (isset($term->field_asset_topic_taxonomy['und']) && is_array($term->field_asset_topic_taxonomy['und'])) {
                $topic_count = count($term->field_asset_topic_taxonomy['und']);
                foreach(array_values($term->field_asset_topic_taxonomy['und']) as $tid) {
                    $asset_tids[] = $tid['tid'];
                }
                $asset_count = _get_node_count_by_tid($asset_tids);
            }

            // term_child page count
            $child_term_count =_get_child_terms_count_by_tid($row->tid);
            //$term_page_count = _get_node_count_by_tid(array($row->tid));
            //$page_count= $asset_count+$term_page_count;

            $new_title = $view->result[$i]->taxonomy_term_data_name . ' ( '
                . $child_term_count . ' Child Page' . (($child_term_count!=0)?'s':'') . ', '
                . $nav_count . ' Supplemental Nav Link'. (($nav_count!=0)?'s':'') . ', '
                . $asset_count . ' Asset' . (($asset_count!=0)?'s':'') . ', '
                . $topic_count . ' Asset Node' . (($topic_count!=0)?'s':'') . ' )';

            $view->result[$i]->taxonomy_term_data_name = $new_title;
            $i++;
        }
    }
    elseif( $view->name == "content_taxonomy_report" && $view->current_display == "content_tag_report") {
        $is_asset_topic = (isset($view->exposed_data)
            && is_array($view->exposed_data)
            && $view->exposed_data['machine_name'] == 'asset_topic_taxonomy')? TRUE : FALSE;

        $is_site_structure = (isset($view->exposed_data)
            && is_array($view->exposed_data)
            && $view->exposed_data['machine_name'] == 'site_strucutre_taxonomy')? TRUE : FALSE;


        $i=0;
        foreach($view->result as $row){

            $array_tids[]=$row->tid;
            $asset_count = _get_node_count_by_tid(array($row->tid));

            $child_topics = ($is_asset_topic || $is_site_structure) ? _get_child_terms_count_by_tid($row->tid) : 0;

            if ($is_site_structure) {
                // node should be counted differently it will look for regions
                // find asset topic which is assigned to field_data_field_asset_topic_taxonomy
                $asset_tid = _get_region_node_count_by_tid(array($row->tid));
                if (is_numeric($asset_tid)) {
                    $asset_count = _get_node_count_by_tid(array($asset_tid));
                }
                $owner = _get_asset_owner_by_tid($row->tid);
            }

            // JKH updated to check that $owner is set...
            if(isset($owner)) {
               $owner_txt = strlen($owner) > 0? ' is owned by ' . $owner : '' ;
            } else {
               $owner_txt = "owner not set";
            }

            $new_title = $view->result[$i]->taxonomy_term_data_name . $owner_txt . ' ( '
                . $asset_count . ' Asset' . (($asset_count!=0)?'s':'')
                . ($is_asset_topic || $is_site_structure? (', ' . ($child_topics . ' Asset Node' . (($child_topics!=0)?'s':''))) : '')
                . ' )';

            $view->result[$i]->taxonomy_term_data_name = $new_title ;
            $i++;
        }

    }
    elseif($view->name == 'overriden_content_report' && $view->current_display == 'overriden_content_report_page') {

        $new_result = array();
        foreach($view->result as $row) {
            if ($row->users_node_uid != $row->users_node_revision_uid
                && $row->users_node_revision_uid != 0
                && $row->users_node_uid != 0) {
                $new_result[] = $row;
            }

        }
        $view->result = $new_result;
    }
}

function _get_asset_owner_by_tid($tid) {
    $sql_s = "SELECT u.name FROM {field_data_field_term_owner} t
        INNER JOIN {users} u
        WHERE t.field_term_owner_target_id = u.uid AND t.entity_id IN ( $tid )";
    $user = db_query($sql_s)->fetchField();
    return $user;
}

function cmp_misc_form_views_exposed_form_alter(&$form, $form_state) {

    /*if ($form['#id'] == 'views-exposed-form-overriden-content-report-overriden-content-report-page') {
        $form['stamp']['min']['#date_format'] = 'm/d/Y';
        $form['stamp']['max']['#date_format'] = 'm/d/Y';
        dpm($form);
    }*/

}


/**
 * Has this node ever been published
 *
 * @param $node
 *   The node being queried.
 *
 * @return
 *   Boolean, True if any revision of this node had ever been published.
 */
/**/
function cmp_misc_node_ever_published($node) {
    global $user;

    if (isset($node->workbench_moderation) && !empty($node->workbench_moderation['published'])) {
        return true;
    }

    // Get the moderation history of this node.
    $query = db_select('workbench_moderation_node_history', 'm');
    $query->condition('m.nid', $node->nid)
        ->condition('m.state', 'published')
        ->fields('m',array('stamp'));

    $moderations = $query->execute()->rowCount();

    // Make sure it's an array.
    return !empty($moderations);
}
/**/


function cmp_misc_form_alter(&$form, &$form_state, $form_id)
{
    /// check to see if this is a new piece of content
    if ( (  empty($form_state['node'])
            || !isset($form_state['node']->nid)
            ||  isset($form_state['node']->is_new) )
        && in_array($form_id,array(
            'text_content_type_node_form',  'state_details_node_form',
            'state_details_node_form',      'html_content_type_node_form',
            'file_content_type_node_form',  'directory_record_content_type_node_form',
            'multimedia_content_type_node_form' ))
        &&  empty($form['field_owner']['und'][0]['target_id']['#default_value'])
        && strlen($form['field_owner']['und'][0]['target_id']['#default_value']) == 0 )
    {
        global $user;
        $currentUserStr = $user->name . " (" . $user->uid . ") ";
        $form['field_owner']['und'][0]['target_id']['#default_value'] = $currentUserStr;
    }

    if (in_array($form_id,array(
        'text_content_type_node_form',  'state_details_node_form',
        'state_details_node_form',      'html_content_type_node_form',
        'file_content_type_node_form',  'directory_record_content_type_node_form',
        'multimedia_content_type_node_form' ))) {

        drupal_add_js(drupal_get_path('module', 'cmp_misc') .'/js/set_today_options.js');

    }

    // repeating the logic above for the owner fields, except for terms instead of nodes
    if ( !isset($form_state['term']->tid)
        && $form_id == 'taxonomy_form_term'
        &&  empty($form['field_term_owner']['und'][0]['target_id']['#default_value'])
        && strlen($form['field_term_owner']['und'][0]['target_id']['#default_value']) == 0 )
    {
        global $user;
        $currentUserStr = $user->name . " (" . $user->uid . ") ";
        $form['field_term_owner']['und'][0]['target_id']['#default_value'] = $currentUserStr;
    }

    /// hide field for non-top-level term edit forms
    if ( $form_id=='taxonomy_form_term' && isset($form_state['term']->tid) )
    {
        if ( is_array($form['#term']) 
          && !empty($form['#term']['parent']) 
          && isset($form['field_for_use_by']) )
        {
            $form['field_for_use_by']['#access'] = FALSE;
        }
    }

    // If this is the edit form for any node under the 'Text Asset' content-type
    //if ( $form_id === 'text_content_type_node_form' ) {
    /*
        if ( !empty($form['#node']->workbench_moderation) ) {

            global $user;
            $isAdmin = in_array('administrator', $user->roles);

            $workflowState = $form['#node']->workbench_moderation['current']->state;
            $canApproveDelete = user_access('moderate content from awaiting_deletion to deleted',$user);
            $everPublished = cmp_misc_node_ever_published($form['#node']);

            /// if isAdmin : delete button + perm option
            if ( $isAdmin ) { return; } /// admin can always see delete
            /// if !ever_published : delete button
            if ( !$everPublished ) { return; } /// anyone can see delete
            /// if  ever_published &&  awaiting_deletion && !(state:awaiting->deleted) : disabled delete button + message
            if ( $workflowState=='awaiting_deletion' && !$canApproveDelete && !empty($form['actions']['delete']) )
            { // awaiting deletion approval
                $form['actions']['delete']['#value'] = 'Awaiting Deletion';
                $form['actions']['delete']['#type'] = 'button';
                unset($form['actions']['delete']['#submit']);
                $form['actions']['delete']['#attributes'] = array(
                    'style' => 'background-color: lightgray; color: gray; outline: 1px dashed gray;',
                    "onclick" => "return (false);"
                );
                return;
            }
            /// if  ever_published &&  awaiting_deletion &&  (state:awaiting->deleted) : approve soft delete button
            if ( $workflowState=='awaiting_deletion' &&  $canApproveDelete && !empty($form['actions']['delete']) )
            { // approve deletion
                $form['actions']['delete']['#value'] = 'Approve Deletion';
                return;
            }
            /// if  ever_published &&  deleted : show state
            if ( $workflowState=='deleted' && !empty($form['actions']['delete']) )
            {
                $form['actions']['delete']['#value'] = 'Already Deleted';
                $form['actions']['delete']['#type'] = 'button';
                unset($form['actions']['delete']['#submit']);
                $form['actions']['delete']['#attributes'] = array(
                    'style' => 'background-color: lightgray; color: gray; outline: 1px dashed gray;',
                    "onclick" => "return (false);"
                );
                return;
            }
            */
    /*
    $disableDelBtn = false;
     If this user isn't allowed to hard-delete, disabel the delete button if the node is in the soft-delete process
    if ( !$isAdmin && ( $workflowState == 'deleted' || $workflowState == 'awaiting_deletion' ) ) {
        $disableDelBtn = true;
    }

    if ( $disableDelBtn ) {
        $form['actions']['delete']['#value'] = 'Already ' . str_replace('_', ' ', $workflowState);
        $form['actions']['delete']['#type'] = 'button';
        unset($form['actions']['delete']['#submit']);
        $form['actions']['delete']['#attributes'] = array(
            'style' => 'background-color: lightgray; color: gray; outline: 1px dashed gray;',
            "onclick" => "return (false);"
        );
    }
    */
    //}
    //}
}


/**
 * Implements hook_mail_alter
 */
function cmp_misc_mail_alter(&$message) {
    //Sanitize and decode HTML entities in email subject
    // $message['headers']['Content-Type'] = "html/text; charset=UTF-8; format=flowed; delsp=yes";

    // Telling email recipient which environment the email is coming from if not from Prod
    if(!empty(getenv('CMP_DRUPAL_ENVIRONMENT_NAME')) && getenv('CMP_DRUPAL_ENVIRONMENT_NAME') != 'Prod'){
        $message['send'] = FALSE;
        $message['subject'] = '[FROM:' . getenv('CMP_DRUPAL_ENVIRONMENT_NAME') . '] ' . $message['subject'];
    }


}

/*
 * Implements HOOK_node_presave
 */
function cmp_misc_node_presave($node)
{

    watchdog('DBG',__FUNCTION__.' nid:'.$node->nid.' vid:'.$node->vid,[],WATCHDOG_ALERT);

    // Strip trailing empty <p> tags from text-asset body fields
    if ( $node->type == 'text_content_type' && !empty($node->body['und'][0]['value']) ) {
        while ( substr($node->body['und'][0]['value'], -13) === '<p>&nbsp;</p>' ) {
            $strLen = strlen($node->body['und'][0]['value']);
            $bodyVal = $node->body['und'][0]['value'];
            $node->body['und'][0]['value'] = substr($bodyVal, 0, $strLen - 13);
        }
    }

}

/*
 * Implements HOOK_node_insert
 *
 * Pre-save node operations...
 */
function cmp_misc_node_insert($node) {

    // Strip trailing empty <p> tags from text-asset body fields
    if ( $node->type == 'text_content_type' && !empty($node->body['und'][0]['value']) ) {
        while ( substr($node->body['und'][0]['value'], -13) === '<p>&nbsp;</p>' ) {
            $strLen = strlen($node->body['und'][0]['value']);
            $bodyVal = $node->body['und'][0]['value'];
            $node->body['und'][0]['value'] = substr($bodyVal, 0, $strLen - 13);
        }
    }

    // Ensure the "Workflow State (for search indexing)" text-field is initialized
    if ( $node->type === 'text_content_type') {
        $node->field_workflow_state_search = array(
            'und' => array(
                0 => array(
                    'value' => 'draft'
                )
            )
        );
    }

}

function cmp_misc_entity_load($entities, $type)
{
    if ( $type === 'file' )
    {
        foreach ( $entities as $theEntity )
        {
            if ( !isset($theEntity->type) && isset($theEntity->uri) && strpos($theEntity->uri, 's3://') === 0 )
            {
                $theEntity->type = 'image';
            }
        }
    }
    if ( $type === 'node' )
    {
        foreach ( $entities as $theEntity )
        {
            if ( $row = db_query("select uuid from {node} where {node}.nid = {$theEntity->nid}")->fetchAssoc() )
            {
                $theEntity->uuid = $row['uuid'];
            }
        }
    }
}

/*
 * Implementation of hook_cronapi
 */
function cmp_misc_cronapi($op, $job = NULL) {

    $items['cmp_misc_daily_content_scan_cron'] = array(
        'description' => 'Send email to owner about stale/old content',
        'rule' => '0 3 * * *', // Every day at 3am
        'callback' => '_cmp_misc_send_report',
    );

    $items['cmp_misc_monthly_email_SSAssets_report'] = array(
        'description' => 'Monthly creation and emailing of report for Site Structure with Assets',
        'rule' => '0 0 1 * *', // Every first day of a month
        'callback' => '_cmp_misc_email_SSAssets_report_with_attachment',
    );

    $items['cmp_misc_monthly_email_asTT_report'] = array(
        'description' => 'Monthly creation and emailing of report for Asset Topic Taxonomy',
        'rule' => '0 0 1 * *', // Every first day of a month
        'callback' => '_cmp_misc_email_asTT_report_with_attachment',
    );

    $items['cmp_misc_monthly_email_fbo_report'] = array(
        'description' => 'Monthly creation and emailing of report for FBO',
        'rule' => '0 0 1 * *', // Every first day of a month
        'callback' => '_cmp_misc_email_fbo_report_with_attachment',
    );

    $items['cmp_misc_monthly_email_con_report'] = array(
        'description' => 'Monthly creation and emailing of report for Content',
        'rule' => '0 0 1 * *', // Every first day of a month
        'callback' => '_cmp_misc_email_con_report_with_attachment',
    );

    $items['cmp_misc_monthly_email_sst_report'] = array(
        'description' => 'Monthly creation and emailing of report for SST',
        'rule' => '0 0 1 * *', // Every first day of a month
        'callback' => '_cmp_misc_email_sst_report_with_attachment',
    );

    $items['cmp_misc_publish_and_archival_cron'] = array(
        'description' => 'Auto Publishing/Archiving Content',
        'rule' => '*/5 * * * *', // Every 5 minutes to give us time to hit 15min target
        'callback' => '_cmp_misc_check_content_freshness',
    );
    return $items;
}

function _cmp_misc_email_SSAssets_report_with_attachment(){

    $attachment = array(
        'filename' => 'Date-'.date('Y-F-d',time()).'-SiteStructureAssets-report.csv',
        'filemime' => 'text/csv',
        'list' => TRUE
    );

    // Subject
    $params['subject'] = 'Date-'.date('Y-F-d',time()).": Monthly Site Structure Taxonomy Assets Report";

    $h = '';
    // Get the vocabulary-id
    $vocab = taxonomy_vocabulary_machine_name_load('site_strucutre_taxonomy');

    // Initalize the row-counter in the CSV
    $counter = -1;
    $hierarchyLevelSemaphore = -1;
    $rows = array();

    // Compile the report as per the requierments in usagov-100377
    $topTerms = taxonomy_get_tree($vocab->vid, 0, 1);
    foreach ( $topTerms as $topTerm ) {
        compileSiteStructureTaxonomyReportToCSV($counter, $hierarchyLevelSemaphore, $rows, $vocab->vid, $topTerm->tid);
    }

    // Write the CSV headers
    $h .= '"counter","Site","Page Title","Parent Title","Owner","Hierarchy Level","Page Type","Topic Desk Replacement","Friendly URL","CMP Edit Link","Assets on Page",';
    for ( $T = 1 ; $T < intval(variable_get('tssr_lastmaxcolcount', 3)); $T++ ) {
        if ( $T > 1 ) {
            $h .= ',';
        }
        $h .= '"Asset Title '.$T.'"';
    }
    $h .= "\n";

    // Print the CSV content
    foreach ( $rows as $row ) {
        foreach ( array_values($row) as $cellId => $cellValue) {
            if ( $cellId != 0 ) {
                $h .= ",";
            }
            $h .= "\"".$cellValue."\"";
        }
        $h .= "\n";
    }

    // body
    $params['body'] = $h;

    $from = variable_get('forward_sender_address', '');
    if (empty($from)) {
        $from = variable_get('site_mail', '');
    }

    $params['from'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . $from . '>');
    $params['headers']['Reply-To'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . variable_get('site_mail', '') . '>');
    $params['attachment'] = $attachment;
    $to = 'achuluunkhuu@ctacorp.com, david.kaufmann@gsa.gov, marybeth.murphy@gsa.gov, joanne.mcgovern@gsa.gov';
    //$to = 'achuluunkhuu@ctacorp.com';

    try {
      $res = drupal_mail('cmp_misc', 'send_report', trim($to), language_default(), $params, $params['from']);
    } catch(Exception $e) {
      watchdog('cmp mailer',__FUNCTION__.' : '.$e->getMessage() );
      return;
    }
}

function _cmp_misc_email_asTT_report_with_attachment(){

    $attachment = array(
        'filename' => 'Date-'.date('Y-F-d',time()).'-AssetTopicTaxonomy-report.csv',
        'filemime' => 'text/csv',
        'list' => TRUE
    );

    // Subject
    $params['subject'] = 'Date-'.date('Y-F-d',time()).": Monthly AssetTopicTaxonomy Report";

    $h = '';
    // Get the vocabulary-id
    $vocab = taxonomy_vocabulary_machine_name_load('asset_topic_taxonomy');

    // Initalize the row-counter in the CSV
    $counter = -1;
    $hierarchyLevelSemaphore = -1;
    $rows = array();

    // Compile the report as per the requierments in usagov-100377
    $topTerms = taxonomy_get_tree($vocab->vid, 0, 1);
    foreach ( $topTerms as $topTerm ) {
        compileAssetTopicTaxonomyReportToCSV($counter, $hierarchyLevelSemaphore, $rows, $vocab->vid, $topTerm->tid);
    }

    // Write the CSV headers
    $h .= '"counter","Title","Parent Title","Hierarchy Level","Type","CMP Edit Link","Assets-Nodes Associated (cumulative)","For Use By","Owner","Status",';
    for ( $T = 1 ; $T < intval(variable_get('tatr_lastmaxcolcount', 3)); $T++ ) {
        if ( $T > 1 ) {
            $h .= ',';
        }
        $h .= '"Page Title '.$T.'"';
    }
    $h .="\n";

    // Write the CSV content
    foreach ( $rows as $row ) {
        foreach ( array_values($row) as $cellId => $cellValue) {
            if ( $cellId != 0 ) {
                $h .= ",";
            }
            $h .="\"".$cellValue."\"";
        }
        $h .= "\n";
    }

    // body
    $params['body'] = $h;

    $from = variable_get('forward_sender_address', '');
    if (empty($from)) {
        $from = variable_get('site_mail', '');
    }

    $params['from'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . $from . '>');
    $params['headers']['Reply-To'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . variable_get('site_mail', '') . '>');
    $params['attachment'] = $attachment;
    $to = 'achuluunkhuu@ctacorp.com, david.kaufmann@gsa.gov, marybeth.murphy@gsa.gov, joanne.mcgovern@gsa.gov';
    //$to = 'achuluunkhuu@ctacorp.com';

    try {
      $res = drupal_mail('cmp_misc', 'send_report', trim($to), language_default(), $params, $params['from']);
    } catch(Exception $e) {
      watchdog('cmp mailer',__FUNCTION__.' : '.$e->getMessage() );
      return;
    }

}

function _cmp_misc_email_con_report_with_attachment(){

    $attachment = array(
        'filename' => 'Date-'.date('Y-F-d',time()).'-Content-report.csv',
        'filemime' => 'text/csv',
        'list' => TRUE
    );

    // Subject
    $params['subject'] = 'Date-'.date('Y-F-d',time()).": Monthly Content Report";

    $h = '';
    $rows= _compileAssetTopicTaxonomyReportToCSV();
    // Write the CSV headers
    $h .= '"counter","Asset Node ID number","Title","CMP Edit Link","For Use By","Owner","Status","Date Last Reviewed", "Language", "Type of Asset", "# of pages found", "Assigned to taxonomy", "Created Date", "Published Date from Ready from publication", "Most Recent Published Date"';
    $h .="\n";

    $newrows = array();
    $counter =0 ;
    foreach($rows as $row){
        $counter++;
        $row['counter'] =$counter;
        $newrows[] =$row;
    }

    foreach ( $newrows as $row ) {
        foreach ( array_values($row) as $cellId => $cellValue) {
            if ( $cellId != 0 ) {
                $h .= ",";
            }
            $h .= "\"".$cellValue."\"";
        }
        $h .= "\n";
    }

    // body
    $params['body'] = $h;

    $from = variable_get('forward_sender_address', '');
    if (empty($from)) {
        $from = variable_get('site_mail', '');
    }

    $params['from'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . $from . '>');
    $params['headers']['Reply-To'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . variable_get('site_mail', '') . '>');
    $params['attachment'] = $attachment;
    $to = 'achuluunkhuu@ctacorp.com, david.kaufmann@gsa.gov, marybeth.murphy@gsa.gov, joanne.mcgovern@gsa.gov';
    //$to = 'achuluunkhuu@ctacorp.com';

    try {
      $res = drupal_mail('cmp_misc', 'send_report', trim($to), language_default(), $params, $params['from']);
    } catch(Exception $e) {
      watchdog('cmp mailer',__FUNCTION__.' : '.$e->getMessage() );
      return;
    }

}

function _cmp_misc_email_fbo_report_with_attachment(){
    $attachment = array(
        'filename' => 'Date-'.date('Y-F-d',time()).'-FBO-report.csv',
        'filemime' => 'text/csv',
        'list' => TRUE
    );

    // Subject
    $params['subject'] = 'Date-'.date('Y-F-d',time()).": Monthly FBO Report";

    $h = '';
    $newrows= _userinput_report();
    // Write the CSV headers
    $h .= '"Date and Time Submitted","Keyword Filter","Location Filter", "Posted Date Filter", "Setaside Type Filter", "Show Non-Setaside Selector"';
    $h .="\n";

    foreach ( $newrows as $row ) {
        foreach ( array_values($row) as $cellId => $cellValue) {
            if ( $cellId != 0 ) {
                $h .= ",";
            }
            $h .= "\"".$cellValue."\"";
        }
        $h .= "\n";
    }

    // body
    $params['body'] = $h;

    $from = variable_get('forward_sender_address', '');
    if (empty($from)) {
        $from = variable_get('site_mail', '');
    }

    $params['from'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . $from . '>');
    $params['headers']['Reply-To'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . variable_get('site_mail', '') . '>');
    $params['attachment'] = $attachment;
    $to = 'achuluunkhuu@ctacorp.com, david.kaufmann@gsa.gov, marybeth.murphy@gsa.gov, joanne.mcgovern@gsa.gov';
    //$to = 'achuluunkhuu@ctacorp.com';

    try {
      $res = drupal_mail('cmp_misc', 'send_report', trim($to), language_default(), $params, $params['from']);
    } catch(Exception $e) {
      watchdog('cmp mailer',__FUNCTION__.' : '.$e->getMessage() );
      return;
    }

}

function _cmp_misc_email_sst_report_with_attachment(){

    $attachment = array(
        'filename' => 'Date-'.date('Y-F-d',time()).'-SST-report.csv',
        'filemime' => 'text/csv',
        'list' => TRUE
    );

    // Subject
    $params['subject'] = 'Date-'.date('Y-F-d',time()).": Monthly SST Taxonomy Report";

    $h = '';
    unset($site_structure_array);
    $site_structure_array[0]=array('Site','Owner','Hierarchy Level','Page Type','Topic Desk Replacement','Friendly URL','CMP Edit Link','Page ID','Page Title',
        'Parent Title','Level 6','Level 5', 'Level 4', 'Level 3',' Level 2', 'Level 1', 'USAGov Topic Crosswalk', 'GA style URL', 'VOC tool export URL style','Last Changed Date', 'Assets on Page', 'Toggle URL');

    $get_root_level_site_name = taxonomy_get_tree(42,0,1);
    foreach($get_root_level_site_name as $root_level){
        $site_names[$root_level->tid]=$root_level->name;
    }

    foreach($site_names as $root_tid=>$site_name)
    {
        $get_all_terms=taxonomy_get_tree(42,$root_tid);

        foreach($get_all_terms as $get_term) {
            $site_structure_array[]=get_child_info($get_term->tid,$get_term->depth,$site_name);

        }
    }
    foreach ( $site_structure_array as $row ) {
        foreach ( array_values($row) as $cellId => $cellValue) {
            if ( $cellId != 0 ) {
                $h .= ",";
            }
            $h .= "\"".$cellValue."\"";
        }
        $h .= "\n";
    }

    // body
    $params['body'] = $h;

    $from = variable_get('forward_sender_address', '');
    if (empty($from)) {
        $from = variable_get('site_mail', '');
    }

    $params['from'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . $from . '>');
    $params['headers']['Reply-To'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . variable_get('site_mail', '') . '>');
    $params['attachment'] = $attachment;
    $to = 'achuluunkhuu@ctacorp.com, david.kaufmann@gsa.gov, marybeth.murphy@gsa.gov, joanne.mcgovern@gsa.gov';
    //$to = 'achuluunkhuu@ctacorp.com';

    try {
      $res = drupal_mail('cmp_misc', 'send_report', trim($to), language_default(), $params, $params['from']);
    } catch(Exception $e) {
      watchdog('cmp mailer',__FUNCTION__.' : '.$e->getMessage() );
      return;
    }

}

function _cmp_misc_check_content_freshness()
{
    $pub = _cmp_misc_auto_publish_content();
    $arv = _cmp_misc_auto_archive_content();
    watchdog( 'cron', "FreshCheck: Auto-Publish(:pub) Auto-Archive(:arv)",[':pub'=>$pub,':arv'=>$arv],WATCHDOG_WARNING);
}

function _cmp_misc_auto_publish_content()
{
    /// trigger a workflow state transition to published, this will automatically trigger a legit publish as well
    $records = db_query(
        'SELECT
                n.nid
                #,n.vid, n.status, d.deletion_timestamp, a.field_archive_date_value, p.field_schedule_publish_value, w.state
              FROM
                {node} n
                LEFT JOIN {node_deleted}                      d on ( n.nid = d.nid )
                LEFT JOIN {field_data_field_archive_date}     a on ( n.nid = a.entity_id )
                LEFT JOIN {field_data_field_schedule_publish} p on ( n.nid = p.entity_id )
                LEFT JOIN {workbench_moderation_node_history} w on ( n.nid = w.nid AND n.vid = w.vid AND w.is_current = 1 )
              WHERE
                # node is not deleted
                ( d.deletion_state IS NULL OR d.deletion_state != :soft )
                # current revision is not already published
                AND n.status != 1
                # is not archived
                AND NOT (
                    # archive date set
                    a.field_archive_date_value IS NOT NULL
                    AND # archive date is in the past
                    a.field_archive_date_value <= NOW()
                    AND ( # there is no auto-publish date
                        p.field_schedule_publish_value IS NULL
                        OR # the auto-publish date is in the future
                        p.field_schedule_publish_value >= NOW()
                        OR # the auto-publish date was before the auto-archive date
                        p.field_schedule_publish_value <= a.field_archive_date_value
                    )
                )
                # is publishable
                AND ( # has no publish date set
                    p.field_schedule_publish_value IS NULL
                    OR ( # has publish date in the past
                        p.field_schedule_publish_value <= NOW()
                        AND (
                            a.field_archive_date_value IS NULL
                            OR
                            a.field_archive_date_value > NOW()
                            OR # archive date is before publish date
                            a.field_archive_date_value > p.field_schedule_publish_value
                        )
                    )
                )
                AND w.state = :scheduled_for_publication
            ',array( ":soft" => "soft", ":scheduled_for_publication" => "scheduled_for_publication" )
    )->fetchAll();

    foreach  ( $records as $record )
    {
        $node = node_load($record->nid);
        workbench_moderation_moderate($node,workbench_moderation_state_published());
        error_log('Auto Publish: nid='.$node->nid.' vid='.$node->vid.' uuid='.$node->uuid);
    }
    return count($records);
}

function _cmp_misc_auto_archive_content()
{
    /// Just unplublish any nodes with a previous archive date. archive date trumps publication date
    $records = db_query('
              SELECT
                n.nid
                #,n.vid, n.status, d.deletion_state, a.field_archive_date_value
              FROM
                {node} n
                LEFT JOIN {node_deleted} d
                    ON ( n.nid = d.nid )
                LEFT JOIN {field_data_field_archive_date} a
                    ON ( n.nid = a.entity_id )
                LEFT JOIN {field_data_field_schedule_publish} p
                    ON ( n.nid = p.entity_id )
              WHERE
                # node is not deleted
                ( d.deletion_state IS NULL OR d.deletion_state != :soft )
                # any revision of the node is currently published
                AND n.status = 1
                # is archivable
                AND (
                    # archive date set
                    a.field_archive_date_value IS NOT NULL
                    AND # archive date is in the past
                    a.field_archive_date_value <= NOW()
                    AND ( # there is no auto-publish date
                        p.field_schedule_publish_value IS NULL
                        OR # the auto-publish date is in the future
                        p.field_schedule_publish_value >= NOW()
                        OR # the auto-publish date was before the auto-archive date
                        p.field_schedule_publish_value <= a.field_archive_date_value
                    )
                )',
                array( ':soft' => 'soft' )
    )->fetchAll();
    foreach  ( $records as $record )
    {
        $node = node_load($record->nid);
        $node->status = 0;
        node_save($node);
        error_log('Auto Archive: nid='.$node->nid.' vid='.$node->vid.' uuid='.$node->uuid);
        //// do we need to manually set workbench_moderation_state ?
    }
    return count($records);
}

function _cmp_misc_node_is_publishable($node)
{
    /// whole node is deleted
    $is_deleted = db_query(
            'SELECT 1
         FROM {node_deleted} d
         WHERE d.nid=:nid
               AND (
                  d.deletion_state IS NULL
                  OR d.deletion_state != :soft
               )',
            array(':nid'=>$node->nid,':soft'=>'soft')
        )->rowCount() >= 1;
    /// whole node has been archived
    $is_archived = (
        @isset($node->field_archive_date['und'][0]['value'])
        && strtotime($node->field_archive_date['und'][0]['value']) <= time()
        && (
            @empty($node->field_schedule_publish['und'][0]['value'])
            || strtotime($node->field_schedule_publish['und'][0]['value']) > time()
            || strtotime($node->field_schedule_publish['und'][0]['value']) < strtotime($node->field_archive_date['und'][0]['value'])
        )
    );
    /// node is publishable
    $is_scheduled = (
        @empty($node->field_schedule_publish['und'][0]['value'])
        || (
            strtotime($node->field_schedule_publish['und'][0]['value']) <= time()
            && (
                @empty($node->field_archive_date['und'][0]['value'])
                || strtotime($node->field_archive_date['und'][0]['value']) > time()
                || strtotime($node->field_archive_date['und'][0]['value']) < strtotime($node->field_schedule_publish['und'][0]['value'])
            )
        )
    );

    return ( !$is_deleted && !$is_archived && $is_scheduled );
}

function _cmp_misc_get_expiring_nodes()
{
    $expiring_date = strtotime(date('Y-m-d H:i:s') . ' -6 months');
    $kidsnodes = _get_only_kids_contents();

    $sql = "SELECT n.nid, n.title FROM field_data_field_date_last_reviewed lr
        INNER JOIN node n ON n.nid = lr.entity_id
        WHERE n.status = 1 AND
        n.nid NOT IN (SELECT nid FROM node_deleted WHERE deletion_state = 'soft') AND
        UNIX_TIMESTAMP(lr.field_date_last_reviewed_value) <= :start_date";
    $result = db_query($sql, array(':start_date'=>$expiring_date));
    $arr = array();
    foreach($result as $row) {
        if (!in_array($row->nid, $kidsnodes)) {
            $node = node_load($row->nid);

            if (isset($node->field_owner['und'][0]['target_id'])) {
                $user = user_load($node->field_owner['und'][0]['target_id']);
                $arr[$node->field_owner['und'][0]['target_id']]['nodes'][] = l($node->title, 'node/' . $node->nid);
                $arr[$node->field_owner['und'][0]['target_id']]['name'] = $user->name;
                $arr[$node->field_owner['und'][0]['target_id']]['mail'] = $user->mail;
            }
        }
    }
    return $arr;
}

function _get_only_kids_contents(){
    $ret = array();
    $res = db_query("SELECT entity_id as val FROM field_data_field_for_use_by_text WHERE field_for_use_by_text_value LIKE 'Kids.USA.gov'  GROUP BY entity_id HAVING count(field_for_use_by_text_value)=1 ");

    foreach($res as $r){
        $ret[] = $r->val;
    }

    $res = db_query("SELECT entity_id as val, count(field_for_use_by_value) as val2 FROM field_data_field_for_use_by WHERE  entity_type='node'  AND  field_for_use_by_value LIKE 'Kids.USA.gov'  GROUP BY entity_id HAVING count(field_for_use_by_value)=1 ");
    foreach($res as $r){
        $ret[] = $r->val;
    }
    return $ret;
}

function _finally_publish_node($nid,$vid)
{
    watchdog('DBG',__FUNCTION__.' nid:'.$nid.' vid:'.$vid,[],WATCHDOG_ALERT);
    $node = node_load($nid, $vid);
    if ( $node ) {
        workbench_moderation_moderate( $node, workbench_moderation_state_published() );
    }
}

/**
 * Allows modules to respond to state transitions.
 *
 * @param $node
 *  The node that is being transitioned.
 *
 * @param $previous_state
 *  The state of the revision before the transition occurred.
 *
 * @param $new_state
 *  The new state of the revision.
 */
function cmp_misc_workbench_moderation_transition($node, $previous_state, $new_state)
{

    // any state >>> scheduled_for_publication
    // throw this straight to published if we can

    watchdog('DBG',__FUNCTION__.' nid:'.$node->nid.' vid:'.$node->vid.' prev_state:'. $previous_state .' new_state:'.$new_state,[],WATCHDOG_ALERT);

    // sets to publish if the node is publishable
    if ( $new_state=='scheduled_for_publication'
        && _cmp_misc_node_is_publishable($node) )
    {
        drupal_register_shutdown_function('_finally_publish_node', $node->nid, $node->vid);
    }

    // needs approval or needs_acc_approval >>> needs discussion
    if ($previous_state == 'needs_review' && $new_state == 'needs_discussion') {
        $node_vs = node_revision_list($node);
        $node_vs_index = array_keys($node_vs);

        global $user;
        $last_edited_node = $last_edited_user = '';
        if (count($node_vs) > 2) {

            // second revision will be always last person who touched
            for($i=0; $i<count($node_vs); $i++) {
                $tmp_node = $node_vs[$node_vs_index[$i]];

                if ($user->uid != $tmp_node->uid) {
                    $last_edited_node = $node_vs[$node_vs_index[$i]];
                    $last_edited_user = user_load($last_edited_node->uid);
                    break;
                }
            }

            if ($last_edited_node != '' && $last_edited_user != '')  {
                $current_node = $node_vs[$node_vs_index[0]];
                $current_user = user_load($current_node->uid);
                _cmp_misc_send_last_edited_person($last_edited_user, $node);
            }
        }
    }
    elseif($previous_state == 'needs_acc_approval' && $new_state == 'needs_discussion') {

        // http://ctac.myjetbrains.com/youtrack/issue/usagov-100605
        $sql = "SELECT * FROM workbench_moderation_node_history WHERE nid =:node_id AND from_state='draft' AND state='needs_review' ORDER BY stamp ASC LIMIT 1;";
        $node_row = db_query($sql, array(':node_id'=>$node->nid))->fetchAssoc();

        if (isset($node_row['nid']) && isset($node_row['vid'])){
            $node_rev = node_load($node_row['nid'], $node_row['vid']);
            $user_rev = user_load($node_rev->uid);
            _cmp_misc_send_last_edited_person($user_rev, $node, "Person who initially requested node from 'Draft' to 'Needs Approval' is ");
        }
    }

    // needs approval  from different state
    if ($previous_state != 'needs_review' && $new_state == 'needs_review') {
        _cmp_misc_send_needs_approval_notice_person( $node);
    }

    /* Some node(s) have a field_workflow_state_search field, which we want to always contain the current workflow-status.
    We use this field as an easy way to obtain the workflow information with the ElasticSearch mdoule... */
    if ( isset($node->field_workflow_state_search) ) { // If this node is of a content-type that has the workflow_state_search field....

        // Write the (current) workflow-status into the workflow_state_search [text] field...

        /* I am SCHEDULING this, because I am uncertain at what point this hook is called...
        Or in other words: is this hook being triggered on pre-save? post-save? I tried altering $node
        in this function, and found it did not touch the node in the database, but I feel uncomfortable
        loading and saving the node [right here] because the node may be undergoing [an incomplete] alteration
        at this line (in this function) */
        // Schedule helper-function _cmp_misc_setWorkflowStatusSearchTextField() on PHP-thread-termination
        /* register_shutdown_function(
             '_cmp_misc_setWorkflowStatusSearchTextField',
             $node->nid,
             $node->vid,
             $new_state
         );*/

    }

}

/**
 * void _cmp_misc_setWorkflowStatusSearchTextField(int $nid, string $workFlowStatusText)
 *
 * NOTICE: THIS DOES NOT CHANGE NOR TOUCH THE ACTUAL WORKFLOW-STATE IN ANY WAY!
 * This function only writes the given text to the $node->workflow_state_search field, this is
 * a field used only by Elastic-Search.
 *
 * This is created as a helper-function for cmp_misc_workbench_moderation_transition() above.
 */
function _cmp_misc_setWorkflowStatusSearchTextField($nid, $vid, $workFlowStatusText) {

    db_query("
        UPDATE field_data_field_workflow_state_search
        SET field_workflow_state_search_value = '{$workFlowStatusText}'
        WHERE
            entity_id = {$nid}
            AND revision_id = {$vid}
    ");

    db_query("
        UPDATE field_revision_field_workflow_state_search
        SET field_workflow_state_search_value = '{$workFlowStatusText}'
        WHERE
            entity_id = {$nid}
            AND revision_id = {$vid}
    ");

    entity_get_controller('node')->resetCache(array($nid));

    // Debug - for those of us who tail the error_log
    $myFunct = __FUNCTION__;
    error_log(
        "Notice: {$myFunct}() has set the current workflow-status ({$workFlowStatusText}) "
        ."into field_workflow_state_search for node {$nid}/{$vid}"
    );
}

function _cmp_misc_send_needs_approval_notice_person( $node) {

    if (isset( $node->field_workflow_notification_emai['und'][0]['value'])) {
        $to = $node->field_workflow_notification_emai['und'][0]['value'];
        global $user;

        // Subject
        $params['subject'] = "Approval Needed: " . $node->title . _get_env_string();

        $alias = drupal_get_path_alias('node/' . $node->nid);
        // body
        $params['body'] = '<b>Content item needs approval </b> - <a href="' . $alias . '">' . $node->title . '</a> <br/>';
        $params['body'] .= '<b>Summary</b> - ' . $node->field_description['und'][0]['value'] . ' <br/>';
        $params['body'] .= '<b>User who requested review</b> - ' . $user->name . '<br/>';
        $params['body'] .= '<b>Last updated on </b>' . date('Y-m-d - H:i') . '<br/>';
        if ( !empty($node->field_comments['und'][0]['value']) ) {
            $strComment = strip_tags($node->field_comments['und'][0]['value']);
        } else {
            $strComment = '<i>No comments supplied</i>';
        }
        $params['body'] .= '<b>Comments: </b>' . $strComment;

        $from = variable_get('site_mail', '');

        // $params['from'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . $from . '>');
        // $params['headers']['Reply-To'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . variable_get('site_mail', '') . '>');
        $params['from'] = trim(variable_get('site_name', "CMP USA.gov") . ' <' . $from . '>');
        $params['headers']['Reply-To'] = trim(variable_get('site_name', "CMP USA.gov") . ' <' . variable_get('site_mail', '') . '>');

        try {
          $res = drupal_mail('cmp_misc', 'scanning_content', trim($to), language_default(), $params, $params['from']);
        } catch(Exception $e) {
          watchdog('cmp mailer',__FUNCTION__.' : '.$e->getMessage() );
          return;
        }


        if ($res["send"]) {
            drupal_set_message("Approval notification email has been sent." . $to . _get_env_string());
        }
    }
}

function _cmp_misc_send_last_edited_person($user_to_send, $node, $msg=null) {
    $to = $user_to_send->mail;
    global $user;

    // Subject
    $params['subject'] = "Discussion Needed :".$node->title ._get_env_string();

    $alias = drupal_get_path_alias('node/'.$node->nid);
    // body
    $params['body'] = '<b>Content item needs discussion</b> - <a href="' . $alias . '">' . $node->title . '</a> <br/>';
    $params['body'] .= '<b>Summary</b> - ' . $node->field_description['und'][0]['value'] . ' <br/>';
    $params['body'] .= '<b>User who requested discussion</b> - '. $user->name . '<br/>';
    $params['body'] .= '<b>Last updated on </b>' . date('Y-m-d - H:i');

    $from = variable_get('site_mail', '');

    // $params['from'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . $from . '>');
    // $params['headers']['Reply-To'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . variable_get('site_mail', '') . '>');
    $params['from'] = trim(variable_get('site_name', "CMP USA.gov") . ' <' . $from . '>');
    $params['headers']['Reply-To'] = trim(variable_get('site_name', "CMP USA.gov") . ' <' . variable_get('site_mail', '') . '>');

    try {
      $res = drupal_mail('cmp_misc', 'scanning_content', trim($to), language_default(), $params, $params['from']);
    } catch(Exception $e) {
      watchdog('cmp mailer',__FUNCTION__.' : '.$e->getMessage() );
      return;
    }

    if ($res["send"]) {
        drupal_set_message((($msg == null)? "Person who last revision created is ": $msg) . $user_to_send->name . ". Notification email has been sent." . $to ._get_env_string());
    }
}

function _cmp_misc_send_report() {

    // We check and prevent developer's locals from sending emails here
    // $prodStageDomains = variable_get('udm_prod_domains', array());
    if ( !in_array(getenv('CMP_DRUPAL_ENVIRONMENT_NAME'), ["Stage","Prod"]) ) {
        drupal_set_message(
            __FUNCTION__.'() blocked from execution as this appears to NOT be a Dev nor Stage environment.',
            'warning',
            false
        );
        return;
    }

    watchdog('cron',"STARTED >> DAILY SCANNING CONTENT: " . date('Y-m-d H:i:s'),[],WATCHDOG_ALERT);

    $ret = _cmp_misc_get_expiring_nodes();
    $subject = "CMP Content Scan Result: " . date('Y-m-d H:i:s');
    $res = "";

    foreach($ret as $t =>$k) {
        $to = $k['mail'];
        $body="Dear " . $k['name'] . ", <br />You have the following content that has not been reviewed for more than 6 months: <br/>";
        $body .= "<ul>";

        foreach($k['nodes'] as $node_link) {
            $body .= '<li>' . $node_link . '</li>';
        }

        $body .= "</ul>";

        // Subject
        $params['subject'] = $subject ._get_env_string();

        // body
        $params['body'] = $body;


        $from = variable_get('forward_sender_address', '');
        if (empty($from)) {
            $from = variable_get('site_mail', '');
        }

        // $params['from'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . $from . '>');
        // $params['headers']['Reply-To'] = trim(mime_header_encode(variable_get('site_name', "CMP USA.gov")) . ' <' . variable_get('site_mail', '') . '>');

        $params['from'] = trim(variable_get('site_name', "CMP USA.gov") . ' <' . $from . '>');
        $params['headers']['Reply-To'] = trim(variable_get('site_name', "CMP USA.gov") . ' <' . variable_get('site_mail', '') . '>');

        try {
          $res = drupal_mail('cmp_misc', 'scanning_content', trim($to), language_default(), $params, $params['from']);
        } catch(Exception $e) {
          watchdog('cmp mailer',__FUNCTION__.' : '.$e->getMessage() );
          return;
        }

        if ($res["send"]) {
            watchdog("cron", "DAILY SCANNING CONTENT SENT AN EMAIL TO " . $to . date('Y-m-d H:i:s'),[],WATCHDOG_ALERT);
        }
        else {
            watchdog("cron", "DAILY SCANNING CONTENT ERROR OCCURRED ". $res["result"],[],WATCHDOG_ALERT);
        }
        // Flood control
        flood_register_event('cmp_misc');
    }

    watchdog('cron',"FINISHED >> DAILY SCANNING CONTENT: ". date('Y-m-d H:i:s'),[],WATCHDOG_ALERT);

    return $res;
}
function cmp_misc_mail($key, &$message, $params) {
    if ( empty($message['subject']) && !empty($params['subject']) ) {
      $message['subject'] = $params['subject'];
    }
    if ( empty($message['body']) && !empty($params['body']) ) {
      if ( is_array($params['body']) ) {
        $message['body'] = array_merge( $message['body'], $params['body'] );
      } else {
        $message['body'][] = $params['body'];
      }
    }
    $language = $message['language'];
    // if ($key == 'scanning_content') {
    $message['headers']['MIME-Version'] = '1.0';
    $message['headers']['Reply-To'] = $params['headers']['Reply-To'];
    $message['headers']['Content-Type'] = 'text/html; charset=UTF-8; format=flowed; delsp=yes';
    if ( array_key_exists('attachment',$params) && !empty($params['attachment']) )
    {
        $message['headers']['Content-Disposition'] = 'attachment; filename="'. $params['attachment']['filename'].'"';
    }
    if ( array_key_exists('attachment',$message) && !empty( $message['attachment']) )
    {
        $message['params']['attachments'][] =  $message['attachment'];
    }
    // }
    // elseif ($key == 'send_report') {
    //     $message['headers'] = array(
    //         'MIME-Version' => '1.0',
    //         'Content-Type' => 'text/html; charset=UTF-8; format=flowed; delsp=yes',
    //         'Content-Transfer-Encoding' => '8Bit',
    //         'X-Mailer' => 'Drupal',
    //         'Content-Disposition' => 'attachment; filename="'. $params['attachment']['filename'].'"',
    //     );
    //     $message['params']['attachments'][] =  $message['attachment'];
    // }
}

class Cmp_miscMailSystem implements MailSystemInterface {
    /**
     * Concatenate and wrap the e-mail body for plain-text mails.
     *
     * @param $message
     *   A message array, as described in hook_mail_alter().
     *
     * @return
     *   The formatted $message.
     */
    public function format(array $message) {
        $message['body'] = implode("\n\n", $message['body']);
        return $message;
    }

    /**
     * Send an e-mail message, using Drupal variables and default settings.
     *
     * @see http://php.net/manual/en/function.mail.php
     * @see drupal_mail()
     *
     * @param $message
     *   A message array, as described in hook_mail_alter().
     * @return
     *   TRUE if the mail was successfully accepted, otherwise FALSE.
     */
    public function mail(array $message) {
        $mimeheaders = array();
        foreach ($message['headers'] as $name => $value) {
            $mimeheaders[] = $name . ': ' . mime_header_encode($value);
        }
        $line_endings = variable_get('mail_line_endings', MAIL_LINE_ENDINGS);
        return mail(
            $message['to'],
            mime_header_encode($message['subject']),
            // Note: e-mail uses CRLF for line-endings. PHP's API requires LF
            // on Unix and CRLF on Windows. Drupal automatically guesses the
            // line-ending format appropriate for your system. If you need to
            // override this, adjust $conf['mail_line_endings'] in settings.php.
            preg_replace('@\r?\n@', $line_endings, $message['body']),
            // For headers, PHP's API suggests that we use CRLF normally,
            // but some MTAs incorrectly replace LF with CRLF. See #234403.
            join("\n", $mimeheaders)
        );
    }
}

/**
 * Implements hook_search_api_alter_callback_info()
 */
function cmp_misc_search_api_alter_callback_info() {
    $callbacks['most_recent_revision_alter'] = array(
        'name' => t('Index Most Recent Revision'),
        'description' => t('Indexes most recent revision content information to the index.'),
        'class' => 'MostRecentRevisionStateAlterSettings',
        'weight' => 100,
    );

    return $callbacks;
}

/**
 * @file
 * Search API data alteration callback that changes data before send to elastic search
 */
class MostRecentRevisionStateAlterSettings extends SearchApiAbstractAlterCallback {

    public function alterItems(array &$items) {
        foreach ($items as $id => &$item) {

            $sql = "SELECT MAX(vid) FROM {node_revision} WHERE nid =:nid";
            $recent_vid = db_query($sql, array(':nid'=>$id))->fetchField();

            $sql = 'SELECT vid FROM {node} WHERE nid=:nid ';
            $node_vid = db_query($sql, array(':nid'=>$id))->fetchField();

            $current_node = node_load($id, $recent_vid);
            if ($recent_vid != $node_vid) {

                foreach($current_node as $key => $value) {
                    if(property_exists($item, $key)) {
                        $item->{$key} = $value ;
                    }
                }
            }
            if ( isset($current_node->workbench_moderation) ) {
                $item->field_workflow_state_search['und'][0]['value']= $current_node->workbench_moderation['current']->state;
                $item->field_workflow_state_search['und'][0]['safe_value']= $current_node->workbench_moderation['current']->state;
            }
            // node is text or directory content type, we need to add use by field
            if ($current_node->type == 'directory_record_content_type' || $current_node->type == 'text_content_type') {
                if ( isset($item->field_for_use_by_text) ) {
                    $item->field_for_use_by = $item->field_for_use_by_text;
                }
            }
            else {
                if ( isset($item->field_for_use_by) ) {
                    $item->field_for_use_by_text = $item->field_for_use_by;
                }
            }
        }
    }

}

function cmp_misc_wysiwyg_editor_settings_alter(&$settings, $context)
{
    if ( trim(strtolower($context['profile']->editor)) === 'ckeditor')
    {
        // $m = menu_get_item();
        // if ( isset($m['page_arguments']) && isset($m['page_arguments'][0]) )
        // {
        //   $l = null;
        //   if ( !empty($m['page_arguments'][0]->nid) )
        //   {
        //     $meta = entity_metadata_wrapper('node', $m['page_arguments'][0]);
        //     $fl = $meta->field_language->value();
        //     if      ( $fl == 'English' ) { $l = 'en_US'; }
        //     else if ( $fl == 'Spanish' ) { $l = 'es_ES'; }
        //   } else if ( !empty($m['page_arguments'][0]->language) ) {
        //     $l = $m['page_arguments'][0]->language;
        //     if      ( $l == 'en' ) { $l = 'en_US'; }
        //     else if ( $l == 'es' ) { $l = 'es_ES'; }
        //   }
        //   if ( !empty($l) )
        //   {
        //     $settings['scayt_sLang'] = $l;
        //   }
        // }
        $settings['scayt_autoStartup'] = TRUE;
    }
}

function cmp_misc_elasticsearch_connector_clusters_alter( &$clusters )
{
    $shortcode  = variable_get('elasticsearch_shortcode');
    $server_url = _cmp_misc_elasticsearch_server();
    if ( empty($shortcode) || empty($server_url) )
    {
        return;
    }
    foreach ( $clusters as &$cluster )
    {
        if ( stristr($cluster->url,$shortcode) !== false ) {
            $cluster->url = $server_url;
        }
    }
    // $host      = variable_get('elasticsearch_server');
    // $port      = variable_get('elasticsearch_port');
    // if ( empty($shortcode) || empty($host) )
    // {
    //     return;
    // }
    // foreach ( $clusters as &$cluster )
    // {
    //     $regex  = '/'.preg_replace('/(\W)/','\\\\\1',$shortcode).'(:\d+)?/';
    //     $server = empty($port) ? "$host" : "$host:$port";
    //     $altered_url = preg_replace($regex,$server,$cluster->url);
    //     if ( !empty($altered_url) && $altered_url !== $cluster->url )
    //     {
    //         error_log($cluster->url.' >> '.$altered_url);
    //         $cluster->url = $altered_url;
    //         // db_query("UPDATE elasticsearch_connector_cluster
    //         //           SET url=:altered_url WHERE cluster_id=:cluster_id",
    //         //           array(':altered_url'=>$url,
    //         //                 ':cluster_id'=>$cluster->cluster_id)
    //         // );
    //     }
    // }
}
function _cmp_misc_elasticsearch_server()
{
    $host = variable_get('elasticsearch_server');
    $port = variable_get('elasticsearch_port');
    $ssl  = variable_get('elasticsearch_ssl', false);
    if ( boolval($ssl)===false || ( is_string($ssl) && strlen($ssl)>0 && in_array(strtolower($ssl{0}),['n','f']) ) ) {
        $ssl = false;
    } else {
        $ssl = true;
    }
    $scheme = ( $port=='443' || $ssl ) ? 'https' : 'http';
    return $scheme .'://'. $host . ':'. $port;
}

function cmp_misc_wysiwyg_plugin($editor, $version) 
{
    if ($editor == 'ckeditor') {
      return array(
        'noinlinestyles' => array(
          #'url' => 'https://www.usa.gov',
          'path' => drupal_get_path('module', 'cmp_misc') . '/plugins/noinlinestyles',
          'file' => 'plugin.js',
          'extensions' => array(
            'noinlinestyles' => t('No Inline Styles'),
          ),
          'load' => TRUE,
        ),
      );
    }
}

if ( !function_exists('_bloggov_urlFriendlyString') )
{
    function _bloggov_urlFriendlyString($string) {

        $string = _diacritichandler_remove_accents($string);

        $string = trim($string);
        $string = strtolower($string);
        $string = preg_replace('/[\x00-\x1F\x80-\xFF]/', '', $string);

        $replaceWithDashe = array('_', '/', "\\", ' ', '.', '~', '(', ')', '[', ']', ':', ';', '!', '@', '”', '"', "'", "?");

        $string = str_replace($replaceWithDashe, '-', $string);

        while ( strpos($string, '--') !== false ) {
            $string = str_replace('--', '-', $string);
        }

        // convert diacritics

        // $string = strtr($string, array(
        //     ' '=>'-', 'Š'=>'S', 'š'=>'s', 'Ð'=>'Dj', 'Ž'=>'Z', 'ž'=>'z', 'C'=>'C', 'c'=>'c', 'C'=>'C', 'c'=>'c',
        //     'À'=>'A', 'Á'=>'A', 'Â'=>'A', 'Ã'=>'A', 'Ä'=>'A', 'Å'=>'A', 'Æ'=>'A', 'Ç'=>'C', 'È'=>'E', 'É'=>'E',
        //     'Ê'=>'E', 'Ë'=>'E', 'Ì'=>'I', 'Í'=>'I', 'Î'=>'I', 'Ï'=>'I', 'Ñ'=>'N', 'Ò'=>'O', 'Ó'=>'O', 'Ô'=>'O',
        //     'Õ'=>'O', 'Ö'=>'O', 'Ø'=>'O', 'Ù'=>'U', 'Ú'=>'U', 'Û'=>'U', 'Ü'=>'U', 'Ý'=>'Y', 'Þ'=>'B', 'ß'=>'Ss',
        //     'à'=>'a', 'á'=>'a', 'â'=>'a', 'ã'=>'a', 'ä'=>'a', 'å'=>'a', 'æ'=>'a', 'ç'=>'c', 'è'=>'e', 'é'=>'e',
        //     'ê'=>'e', 'ë'=>'e', 'ì'=>'i', 'í'=>'i', 'î'=>'i', 'ï'=>'i', 'ð'=>'o', 'ñ'=>'n', 'ò'=>'o', 'ó'=>'o',
        //     'ô'=>'o', 'õ'=>'o', 'ö'=>'o', 'ø'=>'o', 'ù'=>'u', 'ú'=>'u', 'û'=>'u', 'ý'=>'y', 'ý'=>'y', 'þ'=>'b',
        //     'ÿ'=>'y', 'R'=>'R', 'r'=>'r', "'"=>'-', '"'=>'-', '?'=>''
        // ));

        $string = trim($string, '-');
        return $string;
    }
}

if ( !function_exists('_diacritichandler_remove_accents') )
{
    function _diacritichandler_remove_accents($string)
    {
        if ( !preg_match('/[\x80-\xff]/', $string) )
            return $string;

        if (_diacritichandler_seems_utf8($string)) {
            $chars = array(
                // Decompositions for Latin-1 Supplement
                chr(194).chr(170) => 'a', chr(194).chr(186) => 'o',
                chr(195).chr(128) => 'A', chr(195).chr(129) => 'A',
                chr(195).chr(130) => 'A', chr(195).chr(131) => 'A',
                chr(195).chr(132) => 'A', chr(195).chr(133) => 'A',
                chr(195).chr(134) => 'AE',chr(195).chr(135) => 'C',
                chr(195).chr(136) => 'E', chr(195).chr(137) => 'E',
                chr(195).chr(138) => 'E', chr(195).chr(139) => 'E',
                chr(195).chr(140) => 'I', chr(195).chr(141) => 'I',
                chr(195).chr(142) => 'I', chr(195).chr(143) => 'I',
                chr(195).chr(144) => 'D', chr(195).chr(145) => 'N',
                chr(195).chr(146) => 'O', chr(195).chr(147) => 'O',
                chr(195).chr(148) => 'O', chr(195).chr(149) => 'O',
                chr(195).chr(150) => 'O', chr(195).chr(153) => 'U',
                chr(195).chr(154) => 'U', chr(195).chr(155) => 'U',
                chr(195).chr(156) => 'U', chr(195).chr(157) => 'Y',
                chr(195).chr(158) => 'TH',chr(195).chr(159) => 's',
                chr(195).chr(160) => 'a', chr(195).chr(161) => 'a',
                chr(195).chr(162) => 'a', chr(195).chr(163) => 'a',
                chr(195).chr(164) => 'a', chr(195).chr(165) => 'a',
                chr(195).chr(166) => 'ae',chr(195).chr(167) => 'c',
                chr(195).chr(168) => 'e', chr(195).chr(169) => 'e',
                chr(195).chr(170) => 'e', chr(195).chr(171) => 'e',
                chr(195).chr(172) => 'i', chr(195).chr(173) => 'i',
                chr(195).chr(174) => 'i', chr(195).chr(175) => 'i',
                chr(195).chr(176) => 'd', chr(195).chr(177) => 'n',
                chr(195).chr(178) => 'o', chr(195).chr(179) => 'o',
                chr(195).chr(180) => 'o', chr(195).chr(181) => 'o',
                chr(195).chr(182) => 'o', chr(195).chr(184) => 'o',
                chr(195).chr(185) => 'u', chr(195).chr(186) => 'u',
                chr(195).chr(187) => 'u', chr(195).chr(188) => 'u',
                chr(195).chr(189) => 'y', chr(195).chr(190) => 'th',
                chr(195).chr(191) => 'y', chr(195).chr(152) => 'O',
                // Decompositions for Latin Extended-A
                chr(196).chr(128) => 'A', chr(196).chr(129) => 'a',
                chr(196).chr(130) => 'A', chr(196).chr(131) => 'a',
                chr(196).chr(132) => 'A', chr(196).chr(133) => 'a',
                chr(196).chr(134) => 'C', chr(196).chr(135) => 'c',
                chr(196).chr(136) => 'C', chr(196).chr(137) => 'c',
                chr(196).chr(138) => 'C', chr(196).chr(139) => 'c',
                chr(196).chr(140) => 'C', chr(196).chr(141) => 'c',
                chr(196).chr(142) => 'D', chr(196).chr(143) => 'd',
                chr(196).chr(144) => 'D', chr(196).chr(145) => 'd',
                chr(196).chr(146) => 'E', chr(196).chr(147) => 'e',
                chr(196).chr(148) => 'E', chr(196).chr(149) => 'e',
                chr(196).chr(150) => 'E', chr(196).chr(151) => 'e',
                chr(196).chr(152) => 'E', chr(196).chr(153) => 'e',
                chr(196).chr(154) => 'E', chr(196).chr(155) => 'e',
                chr(196).chr(156) => 'G', chr(196).chr(157) => 'g',
                chr(196).chr(158) => 'G', chr(196).chr(159) => 'g',
                chr(196).chr(160) => 'G', chr(196).chr(161) => 'g',
                chr(196).chr(162) => 'G', chr(196).chr(163) => 'g',
                chr(196).chr(164) => 'H', chr(196).chr(165) => 'h',
                chr(196).chr(166) => 'H', chr(196).chr(167) => 'h',
                chr(196).chr(168) => 'I', chr(196).chr(169) => 'i',
                chr(196).chr(170) => 'I', chr(196).chr(171) => 'i',
                chr(196).chr(172) => 'I', chr(196).chr(173) => 'i',
                chr(196).chr(174) => 'I', chr(196).chr(175) => 'i',
                chr(196).chr(176) => 'I', chr(196).chr(177) => 'i',
                chr(196).chr(178) => 'IJ',chr(196).chr(179) => 'ij',
                chr(196).chr(180) => 'J', chr(196).chr(181) => 'j',
                chr(196).chr(182) => 'K', chr(196).chr(183) => 'k',
                chr(196).chr(184) => 'k', chr(196).chr(185) => 'L',
                chr(196).chr(186) => 'l', chr(196).chr(187) => 'L',
                chr(196).chr(188) => 'l', chr(196).chr(189) => 'L',
                chr(196).chr(190) => 'l', chr(196).chr(191) => 'L',
                chr(197).chr(128) => 'l', chr(197).chr(129) => 'L',
                chr(197).chr(130) => 'l', chr(197).chr(131) => 'N',
                chr(197).chr(132) => 'n', chr(197).chr(133) => 'N',
                chr(197).chr(134) => 'n', chr(197).chr(135) => 'N',
                chr(197).chr(136) => 'n', chr(197).chr(137) => 'N',
                chr(197).chr(138) => 'n', chr(197).chr(139) => 'N',
                chr(197).chr(140) => 'O', chr(197).chr(141) => 'o',
                chr(197).chr(142) => 'O', chr(197).chr(143) => 'o',
                chr(197).chr(144) => 'O', chr(197).chr(145) => 'o',
                chr(197).chr(146) => 'OE',chr(197).chr(147) => 'oe',
                chr(197).chr(148) => 'R',chr(197).chr(149) => 'r',
                chr(197).chr(150) => 'R',chr(197).chr(151) => 'r',
                chr(197).chr(152) => 'R',chr(197).chr(153) => 'r',
                chr(197).chr(154) => 'S',chr(197).chr(155) => 's',
                chr(197).chr(156) => 'S',chr(197).chr(157) => 's',
                chr(197).chr(158) => 'S',chr(197).chr(159) => 's',
                chr(197).chr(160) => 'S', chr(197).chr(161) => 's',
                chr(197).chr(162) => 'T', chr(197).chr(163) => 't',
                chr(197).chr(164) => 'T', chr(197).chr(165) => 't',
                chr(197).chr(166) => 'T', chr(197).chr(167) => 't',
                chr(197).chr(168) => 'U', chr(197).chr(169) => 'u',
                chr(197).chr(170) => 'U', chr(197).chr(171) => 'u',
                chr(197).chr(172) => 'U', chr(197).chr(173) => 'u',
                chr(197).chr(174) => 'U', chr(197).chr(175) => 'u',
                chr(197).chr(176) => 'U', chr(197).chr(177) => 'u',
                chr(197).chr(178) => 'U', chr(197).chr(179) => 'u',
                chr(197).chr(180) => 'W', chr(197).chr(181) => 'w',
                chr(197).chr(182) => 'Y', chr(197).chr(183) => 'y',
                chr(197).chr(184) => 'Y', chr(197).chr(185) => 'Z',
                chr(197).chr(186) => 'z', chr(197).chr(187) => 'Z',
                chr(197).chr(188) => 'z', chr(197).chr(189) => 'Z',
                chr(197).chr(190) => 'z', chr(197).chr(191) => 's',
                // Decompositions for Latin Extended-B
                chr(200).chr(152) => 'S', chr(200).chr(153) => 's',
                chr(200).chr(154) => 'T', chr(200).chr(155) => 't',
                // Euro Sign
                chr(226).chr(130).chr(172) => 'E',
                // GBP (Pound) Sign
                chr(194).chr(163) => '',
                // Vowels with diacritic (Vietnamese)
                // unmarked
                chr(198).chr(160) => 'O', chr(198).chr(161) => 'o',
                chr(198).chr(175) => 'U', chr(198).chr(176) => 'u',
                // grave accent
                chr(225).chr(186).chr(166) => 'A', chr(225).chr(186).chr(167) => 'a',
                chr(225).chr(186).chr(176) => 'A', chr(225).chr(186).chr(177) => 'a',
                chr(225).chr(187).chr(128) => 'E', chr(225).chr(187).chr(129) => 'e',
                chr(225).chr(187).chr(146) => 'O', chr(225).chr(187).chr(147) => 'o',
                chr(225).chr(187).chr(156) => 'O', chr(225).chr(187).chr(157) => 'o',
                chr(225).chr(187).chr(170) => 'U', chr(225).chr(187).chr(171) => 'u',
                chr(225).chr(187).chr(178) => 'Y', chr(225).chr(187).chr(179) => 'y',
                // hook
                chr(225).chr(186).chr(162) => 'A', chr(225).chr(186).chr(163) => 'a',
                chr(225).chr(186).chr(168) => 'A', chr(225).chr(186).chr(169) => 'a',
                chr(225).chr(186).chr(178) => 'A', chr(225).chr(186).chr(179) => 'a',
                chr(225).chr(186).chr(186) => 'E', chr(225).chr(186).chr(187) => 'e',
                chr(225).chr(187).chr(130) => 'E', chr(225).chr(187).chr(131) => 'e',
                chr(225).chr(187).chr(136) => 'I', chr(225).chr(187).chr(137) => 'i',
                chr(225).chr(187).chr(142) => 'O', chr(225).chr(187).chr(143) => 'o',
                chr(225).chr(187).chr(148) => 'O', chr(225).chr(187).chr(149) => 'o',
                chr(225).chr(187).chr(158) => 'O', chr(225).chr(187).chr(159) => 'o',
                chr(225).chr(187).chr(166) => 'U', chr(225).chr(187).chr(167) => 'u',
                chr(225).chr(187).chr(172) => 'U', chr(225).chr(187).chr(173) => 'u',
                chr(225).chr(187).chr(182) => 'Y', chr(225).chr(187).chr(183) => 'y',
                // tilde
                chr(225).chr(186).chr(170) => 'A', chr(225).chr(186).chr(171) => 'a',
                chr(225).chr(186).chr(180) => 'A', chr(225).chr(186).chr(181) => 'a',
                chr(225).chr(186).chr(188) => 'E', chr(225).chr(186).chr(189) => 'e',
                chr(225).chr(187).chr(132) => 'E', chr(225).chr(187).chr(133) => 'e',
                chr(225).chr(187).chr(150) => 'O', chr(225).chr(187).chr(151) => 'o',
                chr(225).chr(187).chr(160) => 'O', chr(225).chr(187).chr(161) => 'o',
                chr(225).chr(187).chr(174) => 'U', chr(225).chr(187).chr(175) => 'u',
                chr(225).chr(187).chr(184) => 'Y', chr(225).chr(187).chr(185) => 'y',
                // acute accent
                chr(225).chr(186).chr(164) => 'A', chr(225).chr(186).chr(165) => 'a',
                chr(225).chr(186).chr(174) => 'A', chr(225).chr(186).chr(175) => 'a',
                chr(225).chr(186).chr(190) => 'E', chr(225).chr(186).chr(191) => 'e',
                chr(225).chr(187).chr(144) => 'O', chr(225).chr(187).chr(145) => 'o',
                chr(225).chr(187).chr(154) => 'O', chr(225).chr(187).chr(155) => 'o',
                chr(225).chr(187).chr(168) => 'U', chr(225).chr(187).chr(169) => 'u',
                // dot below
                chr(225).chr(186).chr(160) => 'A', chr(225).chr(186).chr(161) => 'a',
                chr(225).chr(186).chr(172) => 'A', chr(225).chr(186).chr(173) => 'a',
                chr(225).chr(186).chr(182) => 'A', chr(225).chr(186).chr(183) => 'a',
                chr(225).chr(186).chr(184) => 'E', chr(225).chr(186).chr(185) => 'e',
                chr(225).chr(187).chr(134) => 'E', chr(225).chr(187).chr(135) => 'e',
                chr(225).chr(187).chr(138) => 'I', chr(225).chr(187).chr(139) => 'i',
                chr(225).chr(187).chr(140) => 'O', chr(225).chr(187).chr(141) => 'o',
                chr(225).chr(187).chr(152) => 'O', chr(225).chr(187).chr(153) => 'o',
                chr(225).chr(187).chr(162) => 'O', chr(225).chr(187).chr(163) => 'o',
                chr(225).chr(187).chr(164) => 'U', chr(225).chr(187).chr(165) => 'u',
                chr(225).chr(187).chr(176) => 'U', chr(225).chr(187).chr(177) => 'u',
                chr(225).chr(187).chr(180) => 'Y', chr(225).chr(187).chr(181) => 'y',
                // Vowels with diacritic (Chinese, Hanyu Pinyin)
                chr(201).chr(145) => 'a',
                // macron
                chr(199).chr(149) => 'U', chr(199).chr(150) => 'u',
                // acute accent
                chr(199).chr(151) => 'U', chr(199).chr(152) => 'u',
                // caron
                chr(199).chr(141) => 'A', chr(199).chr(142) => 'a',
                chr(199).chr(143) => 'I', chr(199).chr(144) => 'i',
                chr(199).chr(145) => 'O', chr(199).chr(146) => 'o',
                chr(199).chr(147) => 'U', chr(199).chr(148) => 'u',
                chr(199).chr(153) => 'U', chr(199).chr(154) => 'u',
                // grave accent
                chr(199).chr(155) => 'U', chr(199).chr(156) => 'u',
            );

            $string = strtr($string, $chars);
        } else {
            // Assume ISO-8859-1 if not UTF-8
            $chars['in'] = chr(128).chr(131).chr(138).chr(142).chr(154).chr(158)
                .chr(159).chr(162).chr(165).chr(181).chr(192).chr(193).chr(194)
                .chr(195).chr(196).chr(197).chr(199).chr(200).chr(201).chr(202)
                .chr(203).chr(204).chr(205).chr(206).chr(207).chr(209).chr(210)
                .chr(211).chr(212).chr(213).chr(214).chr(216).chr(217).chr(218)
                .chr(219).chr(220).chr(221).chr(224).chr(225).chr(226).chr(227)
                .chr(228).chr(229).chr(231).chr(232).chr(233).chr(234).chr(235)
                .chr(236).chr(237).chr(238).chr(239).chr(241).chr(242).chr(243)
                .chr(244).chr(245).chr(246).chr(248).chr(249).chr(250).chr(251)
                .chr(252).chr(253).chr(255);

            $chars['out'] = "EfSZszYcYuAAAAAACEEEEIIIINOOOOOOUUUUYaaaaaaceeeeiiiinoooooouuuuyy";

            $string = strtr($string, $chars['in'], $chars['out']);
            $double_chars['in'] = array(chr(140), chr(156), chr(198), chr(208), chr(222), chr(223), chr(230), chr(240), chr(254));
            $double_chars['out'] = array('OE', 'oe', 'AE', 'DH', 'TH', 'ss', 'ae', 'dh', 'th');
            $string = str_replace($double_chars['in'], $double_chars['out'], $string);
        }

        return $string;
    }
}
if ( !function_exists('_diacritichandler_seems_utf8') )
{
    function _diacritichandler_seems_utf8($str)
    {
        $length = strlen($str);
        for ($i=0; $i < $length; $i++) {
            $c = ord($str[$i]);
            if ($c < 0x80) $n = 0; # 0bbbbbbb
            elseif (($c & 0xE0) == 0xC0) $n=1; # 110bbbbb
            elseif (($c & 0xF0) == 0xE0) $n=2; # 1110bbbb
            elseif (($c & 0xF8) == 0xF0) $n=3; # 11110bbb
            elseif (($c & 0xFC) == 0xF8) $n=4; # 111110bb
            elseif (($c & 0xFE) == 0xFC) $n=5; # 1111110b
            else return false; # Does not match any model
            for ($j=0; $j<$n; $j++) { # n bytes matching 10bbbbbb follow ?
                if ((++$i == $length) || ((ord($str[$i]) & 0xC0) != 0x80))
                    return false;
            }
        }
        return true;
    }
}

// if it is empty, assume PROD
function _get_env_string() {
    $ret = "";
    if (strpos($_SERVER["HTTP_HOST"], "test") !== FALSE)
        $ret = " TEST";
    elseif(strpos($_SERVER["HTTP_HOST"], "stage") !== FALSE)
        $ret = " STAGE";

    return $ret;
}
